---
title: Creating Themes
description: Learn how to create a suite of themes for a Tamagui app.
---

<IntroParagraph>
  The new ThemeBuilder API allows for intuitively creating entire suites of themes for use
  with your design system on Tamagui with a simple syntax.
</IntroParagraph>

The Tamagui theme system is powerful, perhaps even too much for its own good. In the past, this complexity, combined with a relative lack of documentation, meant rolling your own theme suite was too much of a bother for most.

With version 1.37 Tamagui is releasing two new things: a "ThemeBuilder", exported as `createThemeBuilder` from `@tamagui/create-theme`, and a corresponding compile-time option `themeBuilder`.

The new ThemeBuilder makes it dramatically easier to generate a theme suite, while the `themeBuilder` option automates pre-generating themes and therefore avoids the cost of generating themes at runtime (as well as avoiding the extra bundle size of the `@tamagui/create-theme` package).

This guide goes into the concepts behind the ThemeBuilder, and ends with [a complete example](#complete-example).

<Aside>

### A bit of history

Tamagui has gone through many stages of "theme builders", ie functional APIs that let you generate a suite of themes. It means the current version is the result of a lot of iteration, and we think its led to a better outcome than if we had pushed out something quickly.

#### The first attempt

In the beginning there was simply a big imperative ball of goop that we recommended copy/pasting into your own app. We eventually put that behind a very ad-hoc and rigid single function that let you customize the base palettes, but nothing below that.

#### The second attempt

Our first attempt at formalizing the theme system came around version 1.2, with `@tamagui/create-theme`, which added a variety of concepts and helper functions. These basically let you generate your own full suite of themes from base palettes, as well as two new ideas, "templates" and "masks". Templates would simply pick values off a palette, where a mask could take a previous template and generate a new one based off of it.

These concepts were key in allowing for the new API to work. But still, it was a lot of work to put together a theme suite, and the resulting code was fairly verbose. We also never fully got around to documenting the system, as it was clear there were a variety of improvements to be made. So we still recommended just copy/pasting the themes config we built, and left users on their own.

#### The current attempt

With version 1.37 we're officially documenting and making a new ThemeBuilder first-class. It further builds off the work in `@tamagui/create-theme`, adding a layer above all the helper functions we previously created. Instead of having to import 6-7 different functions and compose them together yourself, you can import a single function, `createThemeBuilder`, which has a chained API that makes the resulting code far more elegant and readable.

It also has a variety of improvements - it makes it far easier to change your themes at any "level," while still sharing code at any other level. Further, it makes the idea of a palette and mask first class and named, which is key for us going forward with the [Studio](/studio). This means we can now have two-way sync with the Tamagui Studio - we can understand not just your themes, but the palettes, templates and masks you used the generate theme, but also, we can write back out to them if you change them within the visual affordances the Studio begets.

All in all this means that generating a complete suite of themes is now not only easy, but within reach of anyone, even designers! This is especially true as it's super easy to actually keep all the masks and templates the same, but just swap out the root level palettes. We expect an explosion of theme suites will bloom due to the big wins in ease of use enabled by the new `@tamagui/create-theme`.

</Aside>

---

### The Concepts

The way the new ThemeBuilder works is through three main concepts: a palette, a template, and a mask. It's worth understanding each and how they relate to a design system before getting your hands dirty.

But first - what is a theme?

#### Themes

A theme is simple, it's a static typed object with properties that map from name => color. The simplest example is this:

```tsx
{
  background: '#000',
  color: '#fff',
}
```

You can have as many values as you want in your themes, but what's important is that they share the same shape. Of course Tamagui themes [go rather deep with their support of sub-themes](/docs/intro/themes) that can be a subset of their parents'. But this is the only important thing to remember - themes all share the same shape, and (as of the current version) simply map to colors.

#### Palettes

The first layer of building a theme starts with a palette. All a palette is is a gradient within a single color, going from background to foreground:

<Blog.ThemeBuilder.ExamplePalette showLabels />

You can toggle dark mode in the top left of the site to see that in fact we have _two_ blue palettes: `light_blue` and `dark_blue`.

Here's a palette in code (the `dark_blue` one):

```tsx
const dark_blue = [
  'hsl(212, 35.0%, 9.2%)', // background
  'hsl(216, 50.0%, 11.8%)',
  'hsl(214, 59.4%, 15.3%)',
  'hsl(214, 65.8%, 17.9%)',
  'hsl(213, 71.2%, 20.2%)',
  'hsl(212, 77.4%, 23.1%)',
  'hsl(211, 85.1%, 27.4%)',
  'hsl(211, 89.7%, 34.1%)',
  'hsl(206, 100%, 50.0%)',
  'hsl(209, 100%, 60.6%)',
  'hsl(210, 100%, 66.1%)',
  'hsl(206, 98.0%, 95.8%)', // foreground
]
```

Palettes are great for a design system because they constrain your color choices to a consistent scale, and designs look better when they have consistency.

We can refer to a single color in the pallete based on their index:

<Blog.ThemeBuilder.ExamplePalette showIndices />

Where in this case 0 is the background, and 11 is the foreground.

Within Tamagui you can define your palettes to have as many of few colors as you like. You also technically don't _have_ to go from background to foreground, but we recommend it if only for being consistent (and for being able to share masks, which we'll get into shortly).

The offical `@tamagui/themes` theme suite that this very websites uses adds one more layer to this equation - the 0-index color is actually a "background transparent", leaving the 1st index as the actual background. Correspondingly, the 12th index is the strongest foreground, while the 13th is "foreground transparent".

#### Templates

The next level up from a palette is a template, and templates are very simple: they simply maps a _name to an index of a palette_.

The name can be any name you want, and the index just refers to an offset of your palette. In practice, it looks something like this:

```tsx
{
  background: 0,
  color: 12
}
```

The **why** behind templates will become apparent soon, but first lets see **how** they are used. First, we can make a function that takes a palette and returns a theme:

```tsx
const createTheme = (palette: string[]) => ({
  background: palette[0],
  color: palette[12],
})
```

Which leads us naturally to combining palette + template:

```tsx
const createTheme = (palette: string[], template: Record<string, number>) => ({
  background: palette[template.background],
  color: palette[template.color],
})
```

Of course you can abstract this so it works with any type of template:

```tsx
const createTheme = (palette: string[], template: Record<string, number>) => {
  return Object.fromEntries(
    Object.entries(template).map(([key, offset]) => [
      // returns an object with keys from the template, values from the palette
      key,
      palette[offset],
    ])
  )
}
```

Before we get lost in the weeds, lets get into why we even want templates. To do that we need to first udnerstand that we often share the same shape of themes across different sub-themes, and so the idea of a generic template is useful.

For example, we may have two different color palettes that closely match in their brightness/saturation, while differing in their hue:

<Blog.ThemeBuilder.ExamplePalette theme="blue" />
<Blog.ThemeBuilder.ExamplePalette theme="red" />

In this case, we could use our `createTheme` function from above and generate a theme for both, simply by swapping out the palette:

```tsx
const colorTemplate = {
  background: 0,
  color: 12,
}

const blue_theme = createTheme(bluePalette, colorTemplate)
const red_theme = createTheme(redPalette, colorTemplate)
```

But it's not just this that makes templates useful, it also comes in handy when we want to modify a theme. In order to really understand that, we'll probably want to just dive right into the last concept in the ThemeBuilder - masks.

#### Masks

Masks are what make sub-themes shine. To understand them, lets start with examples that show why they are needed. In Tamagui, you can nest as many themes as you want. Child themes extend from parent themes like so:

```tsx
const dark_red = {
  background: '#000',
  color: 'red',
}

const dark_red_subtle = {
  background: '#222',
  color: 'red',
}

createTamagui({
  themes: {
    dark_red,
    dark_red_subtle,
  },
})
```

Note that `_subtle` actually makes this `dark_red_subtle` theme a child of the `dark_red` theme. In your code you can now do this:

```tsx
import { Stack, Theme, styled } from '@tamagui/core'

const Square = styled(Stack, {
  background: '$background',
  width: 100,
  height: 100,
})

export default () => (
  <Theme name="dark_red">
    {/* this will have a background of #000 */}
    <Square />

    <Theme name="subtle">
      {/* this will have a background of #222 */}
      <Square />
    </Theme>
  </Theme>
)
```

### How
