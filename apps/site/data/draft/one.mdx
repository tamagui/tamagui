---
title: Tamagui 1.0
publishedAt: '2022-12-24'
description: Ship cross-platform React apps in ¬Ω time with 2x performance.
by: nate
# relatedIds:
#   - 'tamagui-alpha'
---

<IntroParagraph large>
  React Native allows for incredibly native feelings apps, but when you adapt them to the web, they
  feel [clunky](/docs/intro/compiler).
</IntroParagraph>

<IntroParagraph>
  You miss out on using web primitives that *really matter* for performance like media queries,
  pseudo styles, CSS variables. Plus, you end up with a lot of heavy to parse and run JS, when you
  could be using CSS.
</IntroParagraph>

Tamagui is a novel optimizing compiler for React that makes universal styles feel amazing on every platform. It optimizes both to the web and native, often making write-once code perform better than separately written apps with hand-tuned CSS.

**What does that mean in practice?**

<Image
  title="The compiler improves the Lighthouse score of the homepage of https://tamagui.dev from 85 to 96"
  src="/banner-lighthouse.jpg"
  size="hero"
  height={275}
  width={761}
  resizeMode="contain"
  mt="$2"
  mb="$4"
/>

Get a rich yet lightweight CSS-in-JS design system with `@tamagui/core`, fully typed, that optimizes everything - styles, inline styles, inline styles with logic, and more, even flattening entire components into a simple `div` or `View` on native when it can. The difference in performance is huge:

<Spacer />
<BenchmarkChartWeb />
<Spacer />

On top of that, we've built `tamagui`, a complete suite of components and hooks designed to adapt to feel native on every platform, yet still be completely customizable thanks to a uniquely powerful [theme system](/docs/intro/themes), sizing props, and Radix-inspired composable component API surfaces.

Tamagui supports the full APIs of React Native. The optimizing compiler nets huge gains in Lightouse cores - 15-20% on complex pages - without changing a line of code. It turns janky JS-based responsive and pseudo styles into clean CSS that is 10x faster on the web.

And it doesn't just extracting CSS. The key to Tamagui's performance gains lie in **view flattening**.

The compiler analyzes code across module boundaries, and evaluates all types of logic using both logical and VM-based analysis. So long as you aren't spreading properties or using logic it can't interpret, it will fully flatten your custom styled components like `<Circle />` into plain old `<div />` (or `<View />`, on native).

Tamagui consists of three main pieces.

[Core](#overview-of-tamagui-core) is a fully independent style library, with no external dependencies, that is a massive improvement over `StyleSheet.create`, giving you a complete and customizable typed design system, variants, responsive and interaction styles, and much more out of the box.

[Static](#whats-is-static) is the optimizing compiler. It supports web and native through a plugin interface that has adapters for Webpack, Vite, Next, React Native, and Expo.

[Tamagui](#whats-is-tamagui) is a complete UI kit for React Native and Web, where every component is designed to adapt to each platform perfectly. It comes with lightweight yet beautiful default styles, yet you can re-theme every part of it completely without having to write a ton of extra code. And every component accepts a `size` property, meaning you have total control to re-theme, and re-size for incredible amounts of UI flexibility.

## Overview of `@tamagui/core`

Create your own (or use our) fully typed design system that works hand-in-hand with a powerful `styled()` function.

Everything works on Native and Web the same, with no dependencies, at ~15Kb gzipped.

It features **deterministic, easy to reason about styling** that outputs to atomic CSS, always merging styles based on the order received, whether using `styled`, nesting them, or using them with inline props.

```tsx
import { config } from '@tamagui/config-base'
import { Stack, createTamagui, styled } from '@tamagui/core'

// define your typed design system
export const config = createTamagui(config)

// use your tokens and themes easily
export const Circle = styled(Stack, {
  backgroundColor: '$background',
  color: '$color2',
  borderRadius: '$4',

  variants: {
    pin: {
      top: {
        position: 'absolute',
        top: 0,
      },
    },

    size: {
      // functional variants give incredible power and save bundle size
      '...size': (size, { tokens }) => {
        return {
          width: tokens.size[size] ?? size,
          height: tokens.size[size] ?? size,
        }
      },
    },
  } as const,
})
```

Highlights:

- Works 100% the same across Native and Web.
- Works completely at runtime, no compiler step necessary.
- No dependencies. Enjoy the full typed React Native API without the bloat for web-only use cases.
- SSR and React Server Component support for 100% of the features.
- Beautiful typed design systems.
- Powerful typed variants, including functional variants.
- Prop-order based styling means no more CSS specificity fights!
- Inline styles that support 100% of the style API surface area.
- Shorthands for a Tailwind-like authoring experience
- Easily merge styles down the three without worry, typed, easily destructure and spread.

For more, see [configuring](), [styled()], and [variants]() docs.

### Core: Design System

Using [createTamagui](/docs/configuration) you can generate a fully-typed design system with colors, tokens, spacing, sizing, fonts, themes, shorthands, animations, and more, that work with well-optimized and easy to use hooks like [useMedia](/docs/core/use-media) and [useTheme](/docs/core/use-theme).

It works hand-in-hand with a lightweight yet full-featured [styled factory](/docs/core/styled) for CSS-in-JS with all features from variants and shorthand props to media queries, themes, pseudo styles and more, all nicely typed.

The [Stack and Text components](/docs/core/stacks-and-text) work with `styled()` and provide lot of nice features like hover, press, and focus styles, nice inline style props with typed theme and token values, shorthands, media queries, animations, and more (the animations are powered by drivers which can be swapped out, like CSS transition on web, but react-native-reanimated on iOS).

It's a base layer with everything you need for building a full-featured design system.

## What's new in Core

It's all about maturity. Core has had over 500 bugs fixed, landed large performance and memory improvements, and brings compatibility with the latest and greatest in React and React Native.

### React 0.69, React 18, React Native Web 18

Across all of Tamagui, we've bumped support to the latest versions. Due to improvements in react-native-web 18, we were also able to dramatically simplify setup, no longer having to patch the library to support classnames.

### Making web-only use cases shine

Core is an incredibly powerful CSS-in-JS library for React, and the only one that has an optimizing compiler that makes your apps faster. But for web-only use cases, it had a big downside of requiring you to bundle all of `react-native-web` in your app.

For 1.0, we've made `@tamagui/core` have no dependency at all on `react-native-web` when targeting the web, while still maintaining 100% compatibility with the React Native APIs.

This unlocks a few use cases:

- You want all the amazing features of `core` and the optimizing compiler, but you're not targeting native at all, saving ~30Kb of bundle size by avoiding `react-native-web`.
- You're doing the above, but planning to build a Native app in the future.
- You're using Tamagui to target Native and Web, but want to build one-off pages that are web-only while still sharing your typed design system and various Tamagui components.

Now you can get all the benefits of the optimizing compiler and full-featured design system primitives on the web, without the extra bloat if you don't need to bring along the rest of React Native.

### Bundle size reduction

De-coupling core from `react-native` is a big win for web-only use cases. Even beyond that, we've shaved nearly ~12Kb from core through many optimizations all over.

But we've also set up core to go much futher in size savings.

As of today, core is about 18Kb with GZIP. This gives you a whole lot of features, from powerful hooks for themes and media queries, a complete typed design system (tokens, colors, fonts, and more), the truly powerful `styled()` utility function with variants that lets you build type-safe style components that are fast, output atomic CSS, and a all the helpers and hooks that you need to go alongside that.

Going forward, there's a direct path to make core even better for web-only use cases. Directly, we can likely get another 5Kb saved through hand-optimization. And after that, we can split core in half with `@tamagui/web`, which will drop all the unified event and layout APIs from React Native and simply give you back typed web props, bringing the runtime down to below 5Kb.

### Large performance improvements

We've greatly optimized render performance during the beta in a large variety of ways. It's hard to capture every one in a post, but some of the more interesting ones are:

#### `useTheme`

The `useTheme` hook is used by every Tamagui component, and is smart about re-renders by tracking which keys are accessed by your styles to only re-render when their values change. But it wasn't as smart about memory usage and avoiding work up front, and was also re-parenting the React tree too often.

We saw 8% improvements in Lighthouse scores on the website homepage just by optimizing this.

#### `useMedia`

Supporting SSR often means you need to hydrate using an initial value, and then re-render after hydration with the "real" media query value. We've moved over to use React's [useSyncExternalStore hook](https://beta.reactjs.org/apis/react/useSyncExternalStore), which not only greatly reduced the amount of code, but also can avoid double-rendering on hydration if nothing changes.

#### Avoiding work in generating styles

Previously, Core used `react-native-web` to handle the final steps of taking styles and converting them into CSS. In profiling and reading over the code, we found this to be a large bottleneck to performance as it would iterate over objects many times, and generate many intermediate objects in the process.

`@tamagui/core` is now entirely dependency-free and generates it's own styles. In total, de-coupling saved us 4-5 loops over the generated style objects per-component.

### `styled` upgrades

The `styled` factory has undergone a number of improvements. It now supports wrapping any component you give it, so long as that component accepts a `style` prop.

#### A note on `styled` types

We now recommend using `as const` after your `variants` object definition to fix some tricky issues related to some [outstanding Typescript limitations around inferring const generics]().

### Fonts

One theme in the betas for `core` was upgrading how fonts worked. Two big helpers landed:

#### &lt;FontLanguage /&gt;

Supporting fonts per-language is now possible with &lt;FontLanguage /&gt;, like so. First, you can specify language-specific fonts with a suffix in your configuration, much like a sub-theme:

```tsx
const bodyFontEn = createFont({
  family: '"Helvetica"',
  // ... per-font design tokens
})

const bodyFontMandarin = createFont({
  family: '"Helvetica Mandarin"',
  // ... per-font design tokens
})

export const config = createTamagui({
  fonts: {
    body: bodyFontEn,
    body_mandarin: bodyFontMandarin,
  },
})
```

Then you can change the family to Mandarin at any point in your React tree, fully typed:

```tsx
import { FontLanguage, Text } from '@tamagui/core'

export default () => (
  <FontLanguage body="mandarin">
    <Text fontFamily="$body">{/* TODO hello world in mandarin */}</Text>
  </FontLanguage>
)
```

#### `config.fonts.[fontname].face`

React Native makes loading fonts a bit trickier than the web, and the easiest way to do it involved naming your font family differently per-weight. On the web you'd have `Helvetica` and just change `font-weight`, but on Native you set the family from `Helvetica` to `Helvetica Bold` instead of the weight.

Tamagui added support for this through [the `face` option on font configurations]().

### The `themeShallow` prop

The `theme` prop in Tamagui by default will re-theme all sub-component. As of beta `TODO`, Tamagui supports the boolean `themeShallow` prop on any Tamagui component, which will _only_ theme that exact component, leaving all children components with the same theme as their parent.

### Helpers

### The `loadTheme` and `updateTheme` helpers

Themes load in a large variety of tokens for spacing, sizing, radius, colors, and more. They are incredibly powerful, but they also have some cost in bundle size.

The `loadTheme` utility function means you can only load the default themes you want to serve, saving on bundle size, and then add in alternative themes later on.

Meanwhile `updateTheme` gives you the ability to dynamically modify themes on the fly, changing any of their values. On the web, themes work through CSS variables, meaning `updateTheme` is incredibly fast as it avoids all React re-rendering if no theme values are currently being relied on for dynamic styles.

### The `useMediaPropsActive` hook

This hook is useful for authoring your own custom components built on Tamagui. The Tamagui UI kit makes use of this hook extensively.

Tamagui has a philosophy that everything should work at runtime as well as compile-time. The compile-time side just makes it all a lot faster. But working fully runtime, means you have more flexiblity (no need to run any plugins at all), but also lots of power. For example, if Tamagui didn't work fully runtime, you couldn't do dynamic animations at all, let along bringing along [the Reanimated driver]() for beautiful spring or layout animations.

Anyway, the `useMediaPropsActive` hook makes it easy to properly access the "currently active" set of styles given the current screen size, properly typed. Here's an example:

```tsx
import { Stack, StackProps, useMediaPropsActive } from '@tamagui/core'

const CustomWidget = (props: StackProps) => {
  const activeProps = useMediaPropsActive(props)

  console.log(`The current color is`, activeProps.backgroundColor)

  return <Stack {...modifyProps(activeProps)} />
}

export default () => (
  <CustomWidget
    backgroundColor="red"
    $large={{
      backgroundColor: 'green',
    }}
  />
)
```

---

## Static

Over a dozen major improvements to the compiler have made their way in since beta. Some of the highlights are:

### Performance

The compiler uses `babel` to parse and optimize components, which it can get away for performance with largely because it only needs to parse a subset of your files, and it only needs to look for a few areas - namely JSX elements and `styled()` functions. We find that it adds about 10ms of time for each file that it runs on, end-to-end. In exchange, you get massive runtime performance gains and bundle-size reductions.

During the beta we landed many performance improvements. By default now Tamagui avoids even parsing many more files, by only looking for `tsx` or `jsx` extensions by default (configurable with the [`includeExtensions`](/TODO) option).

Tamagui Static now fully bundles your `components` and `config` that you provide it before it begins compilation, writing them out into the `./.tamagui` directory beside your app. This greatly improves debugging and introspection and has led to large improvements in compatibility with many libraries.

### Optimizing more

Previously, Tamagui Static only knew how to optimize components found in your separated design system package. But it's both common and desirable to have one-off `styled()` definitions that are just used for small areas of your app that live alongside those areas, outside your design system.

The compiler now supports analyzing components outside of just your design system, allowing for even less friction when writing apps. It means you can put your `styled()` definitions _anywhere_ without worrying, and Tamagui Static will load and optimize those components as it discovers theme.

### Vite plugin

Tamagui now fully works with Vite 3, both with the compiler and without. A simple `vite.config.js` would look like this:

```tsx
import { tamaguiExtractPlugin, tamaguiPlugin } from '@tamagui/vite-plugin'
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

const tamaguiCompilerConfig = {
  components: ['tamagui'],
  config: 'tamagui.config.ts',
  useReactNativeWebLite: true,
}

export default defineConfig({
  clearScreen: false,
  plugins: [
    react({
      fastRefresh: true,
      jsxPure: true,
    }),
    tamaguiPlugin(tamaguiCompilerConfig),
    tamaguiExtractPlugin(tamaguiCompilerConfig),
  ],
})
```

### Correctness

Most of the work during beta focused on correctness. We've increased testing to cover many more areas, and landed a number of important correctness fixes alongside the ones in `core`.

---

## Tamagui

### A whole lot of new components üéÅ

With the beta release, we had mostly finalized the core feature set we wanted in Tamagui, especially in `@tamagui/core`, the base style system that works underlies the compiler and UI kit. It was time to cut our teeth building out a suite of components to really test it out.

Between then and 1.0, we've released seven new large components that cover some of the most complex use cases you find in any apps. Each comes with a Radix-like composable component API surface that allows for nearly total control over customization - in fact many components were built by taking Radix components APIs, and simply re-building the internal logic to use Tamagui primitives.

Like all existing components in Tamagui, every new component is completely sizable, themable, and able to responsively style using your entire design system.

The new components are:

#### Sheet

A decent bottom sheet is essential for any UI kit, but it represents one of the hardest components to build due to the need for complex interactive behavior at high performance, alongside delicate interplay of touch events between the outer sheet and any inner scrollable content.

This is made especially tricky because Tamagui allows for pluggable animation drivers, letting you choose between using Reanimated, React Native Animated, or simply CSS animations (plus any other animation drivers in the future that the community builds).

This was an excellent test of the unified animation drivers on Tamagui, and unfied interaction primitives of React Native, and we're happy with how it's turned out.

Internally, we've come up with some helpers for each animation driver to support a consistent API for taking a number value and interpolating it with some style properties. Each driver handles this quite differently on the surface, but the Tamagui drivers now give a consistent interface across them all.

#### Select

<HeroContainer>
  <SelectDemo />
</HeroContainer>

Select components are deceptively hard to build. They involve some of the most complex interactions you'll find in any frontend app, as they must support complex keyboard and mouse based behaviors, a lot of accesibility logic, and a UI that adjusts to the window and contents in very dynamic ways.

Luckily, Tamagui stands on the shoulders of giants to make this possible: React Native's unified layout and gesture handling, [Radix](/TODO-link-to-radix-select) which inspired and served as the base structure for the components and their API surface, [Floating UI]() which handles all of the _incredibly complex and finnicky_ logic around interactions and the floating elements.

#### Dialog

[Show content in a Dialog](/docs/components/dialog) that can adapt to another component depending on the screen size.

<HeroContainer>
  <DialogDemo />
</HeroContainer>

```tsx hero template=Dialog

```

#### AlertDialog

Show a Dialog specialized for confirming or denying an action [with AlertDialog](/docs/components/alert-dialog).

<HeroContainer>
  <AlertDialogDemo />
</HeroContainer>

```tsx hero template=AlertDialog

```

AlertDialog is the first of our components to include the `native` prop, which we are excited about. When set to true, it attempts to adapt the element to use platform-primitives when possible For AlertDialog, this means that on iOS, you'll see a native Alert instead the custom Tamagui one.

#### Slider

A [draggable Slider](/docs/components/slider) allows users to input values within a range.

<HeroContainer>
  <SliderDemo />
</HeroContainer>

```tsx hero template=Slider

```

#### Label

Label has been updated to work with all the new form inputs.

<HeroContainer>
  <LabelDemo />
</HeroContainer>

```tsx hero template=Label

```

#### Card

Display content with a header, footer, background image, title, subtitle and description [using Card](/docs/components/card).

<HeroContainer>
  <CardDemo />
</HeroContainer>

```tsx hero template=Card

```

#### ListItem

[ListItem](/docs/components/list-item) allows you to display consistent with title, subtitle, before and after images or icons, and more.

<HeroContainer>
  <ListItemDemo />
</HeroContainer>

```tsx hero template=ListItem

```

#### Avatar

<HeroContainer>
  <AvatarDemo />
</HeroContainer>

```tsx hero template=Avatar

```

#### Spinner

<HeroContainer>
  <SpinnerDemo />
</HeroContainer>

```tsx hero template=Spinner

```

#### Progress

<HeroContainer>
  <ProgressDemo />
</HeroContainer>

```tsx hero template=Progress

```

#### Unspaced

When using the `space` prop, you sometimes want just one area to not add space. This was impossible before, but [with Unspaced now you can](/docs/components/unspaced).

```tsx
<YStack space="$10">
  {/* The components in Unspaced will not be separated */}
  <Unspaced>
    <H1>Title</H1>
    <Paragraph>Sub-title</Paragraph>
    <Paragraph>Author: ...</Paragraph>
    {/* Now you can control the space independently */}
    <Spacer size="$2" />
  </Unspaced>
  <Paragraph>Lorem...</Paragraph>
  <Paragraph>Ipsum...</Paragraph>
  <Paragraph>Dolor...</Paragraph>
</YStack>
```

#### ScrollView

Tamagui [now exports ScrollView](/docs/components/scroll-view), the exact same as React Native ScrollView but with all the Tamagui style props added.

#### XGroup and YGroup

The `Group` component has been split into [XGroup and YGroup](/docs/components/group) to match Stacks. It's been upgraded across the board with the ability to be scrollable and to better handle passing children radius and size styles.

---

### The Kitchen Sink

The monorepo now includes `apps/kitchen-sink` which is an Expo app that loads every demo you see for every component in the [Docs](/docs/TODO).

---

### React Native Animation Driver

---

### Performance

Focus on performance has been a big overarching theme of the beta releases. We've sped up the compiler by about 2x, and the runtime likewise has had an ongoing series of patches that in local tests speed up common use cases likewise by 2-3x.

This is a result of many small changes. For example, on the frontend we changed our style strategy which took extensive refactoring in three stages:

We started with entirely relying on React Native Web's internal style engine, but found it was a big bottleneck both to our correctness, and speed. We instead forked their style system internally, and then step by step went about merging it into our own.

Today the style loop now does 3^N less loops over styles than vanilla React Native.

Animations got a big performance boost by avoiding double-rendering each time they change. This was necessary before because we didn't want to pay the cost of loading all the extra hooks that animations need for every single component, so we had to load a sub-component that would callback when animations were present, leading to a signficant cost only for animated components. Instead, we've landed on a compromise (that will likely be able to be removed in a future release): if a component is going to be animated, always keep the `animation` prop on that component (just set to null, undefined, or false when animations should be off).

---

### Community

- Sponsors
- Community page
- Figma
- Discord
- Starter repos

---

### SSR

Tamagui is the only UI kit that works on both React Native and React Native Web today that supports SSR across every feature and components, right out of the box. During the beta we landed a wide variety of correctness fixes for this functionality.

---

### Vite Plugin + Vite Compiler

---

### React Server Components

---

### react-native-web-lite

---

### Concurrent Mode Support

(ties into react-native-web-lite)

We've updated Tamagui's base React version to be 18, and landed a large amount of fixes relating to concurrent mode.

---

### `@tamagui/next-theme`

---

### `@tamagui/theme-base` upgrades

The default theme package now includes `_active` sub-themes, paving the way for a consistent way to style all active states across every component in `tamagui`.

It also now includes theme values for `color1` => `color12` as part of each theme. This gives you granular access outside of the more specific color values like `background`, or `borderColor`.

---

---

### Starter repos

`create-tamagui-app` underwent some big improvements that will set it up to be much more useful going forward. We moved official starters to be part of the actual Tamagui monorepo itself, which lets us much more rapidly iterate on them, and more importantly, to have them integrated into CI and tested before each release.

It also now leverages a custom home directory `~/.tamagui` directory that will keep track of the last version you used in each app. In the future we can use this to give you automatic upgrade help, and diffs of changes you'll want to make.

The `next-expo-solito` starter repo has had extensive polish as well, with fixes for using Expo EAS out of the box.

---

### Correctness

More than any other section in this release, the biggest amount of effort for 1.0 went into correctness. Nearly every day, Tamagui has steadily landed fixes across every feature and component.

Speaking personally, I'm most proud of the gains made here. The components introduced before the beta were ambitious, and they continued at a rapid pace during beta.

---

### Documentation

The docs have undergone continuous improvements. Some highlights are:

- The [compiler now has an extensive article breaking down the whys and hows of how it works](/docs/intro/compiler).

---

### Testing

We've expanded our testing signficantly, with CI now passing on every merge into master and adding stricted linting and custom validation before every release.

We now have a custom `release.ts` script that controls our release process as well, ensuring releases are tightly coordinated and that starters are integration tested as part of CI.

---

### Benchmarks

---

### Apps in production

We now have multiple users deploying larger scale apps with Tamagui in production.

---

### Acknowledgements

This release once again is inspired by or forks code from a variety of other libraries and developers.

I'd like to thank:

A note on version 1: Tamagui is a big monorepo with many packages and components. We're cutting version 1 because the API's are stable and all the core and compiler¬†packages have received extensive testing and stability work such that every feature works across all platforms reliably - a huge task we can confidently call complete. **That said, when it comes to the Tamagui components, some are more stable than others**. This is more true on Android, where we've invested less overall time towards bug fixes. We could have delayed v1 to stabilize these components, but the truth is that for the dramatic majority of Tamagui everything is at or better than what you'd expect from a stable release. And releasing every package under the same version has immense benefits both for us as developers, and any user as a consumer.
