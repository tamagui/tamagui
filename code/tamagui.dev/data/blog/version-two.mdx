---
title: Tamagui 2
publishedAt: '2025-12-29'
description: More stable, easier to use, better documented.
by: nate
poster: banner-two.jpg
---

<IntroParagraph large>
  Tamagui lets you build apps that share UI across React web and React Native
  without sacrificing quality, simplicity, or performance.
</IntroParagraph>

<IntroParagraph>
  Tamagui is three things: a style library, an optimizing compiler, and a suite
  of UI components. It avoids the usual sacrifices in sharing code by simply
  going quite deep to make that possible. Some examples:
</IntroParagraph>

Tamagui brings many style features from CSS to native, yet all style primitives
work native and web, runtime and compile-time, server-side and client-side. You
get server-side rendering without flickering, even when using spring-based
animation drivers, or with media queries, or themes, and the optimizing compiler
means you can write natural inline styles without the typical performance cost.

In comparison to other solutions, Tamagui is especially strong at:

- _Able to share 100% between web and native._ Many other solutions focus on one
  platform more than others, or implement their features in sub-par ways on web.
- _Great performance and platform feeling on both web and native._ As a small
  example - you can choose from 4 animations drivers (CSS, Reanimated, Motion,
  React Native), per-platform, yet no matter which you choose proper SSR with
  media queries and dark mode properly renders and hydrates.
- _Fast, type-safe, properly mergeable inline styling._ Inline styles are a leap
  forward, but the lack of type safety or easy ability to merge and group your
  styles is their biggest drawback. Tamagui is fully type safe, lets you control
  how you merge styles, and optimizes it all nearly perfectly even in the face
  of complicated logic.
- _A first-class, composable components based UI kit._ Our UI kit doesn't just
  target one platform, uses composable components, and can even adapt based on
  the device.

The result is that Tamagui is the only library that lets you ship world class
experiences on all platforms, with a lot less code. We're proud to be used by
companies like [Uniswap](https://uniswap.org), who leveraged Tamagui to unify
their featureset across platforms and greatly simplify their codebase.

### Improvements during v1

Tamagui improved continuously during version one:

- Added hundreds of tests, stricter lints, dependency checks and a stricter
  release process to improve stability.
- Created
  [`@tamagui/build`](https://github.com/tamagui/tamagui/blob/v2/code/packages/build/README.md),
  the only way to publish npm packages that support CommonJS and ESModules and
  native and web without requiring any configuration at all when importing -
  whether it's Metro, Node, Vite, or otherwise.
- Added many styling features like container queries, container and media
  queries combined, and platform/theme selectors.
- New compound components like Tabs, Accordion, and ToggleGroup.
- Unstyled versions of every component.
- Improved theme generation packages, and released a free visual Theme builder.
- The Takeout starter kit, and Bento copy-paste components and patterns.
- A lot of low level work on performance, documentation, our CLI, and more.

### New in v2

Version two is mostly a cleanup release - it has few breaking changes. It mostly
removes deprecated APIs, while adding a couple new components and refactoring a
couple slow ones.

The breaking changes outside of deprecations are:

- **React Native 0.82+ and React 19+ required.** Tamagui 2 targets React Native
  0.82 and React 19 and above with New Architecture support. This enables
  significant new style features and simplifies internals.
- Default flex and position styles align with the latest React Native versions,
  but you can change settings to keep the legacy behavior.
- Button and ListItem lose direct text style props, to gain performance.
- useTheme no longer takes props, must be changed using a component.
- Removed web-only `onHoverIn` and `onHoverOut` in favor of standard web events
  (`onMouseEnter` or `onPointerEnter`).
- Added comprehensive web event handler support including keyboard, pointer,
  drag and drop, clipboard, and scroll events.
- Move from ThemeableStack to View for most base components used in UI
- Renamed the `animation` prop to `transition` for clarity and consistency

#### CSS Shorthand with Variables

You can now use Tamagui `$variables` directly inside CSS shorthand string values
like `boxShadow`. On web, variables resolve to CSS custom properties; on native,
they resolve to raw values:

```tsx
// Works on both web and native!
<View boxShadow="0 0 10px $shadowColor" />

// Multiple variables work too
<View boxShadow="0 0 5px $shadowColor, 0 0 15px $color" />
```

The `border` shorthand with variables (`border="1px solid $borderColor"`) is
web-only since React Native doesn't support CSS border shorthand syntax. On
native, continue using the individual props (`borderWidth`, `borderColor`,
`borderStyle`).

#### Cross-Platform Style Props

Many style properties that were previously web-only now work on React Native
with the New Architecture:

- **`boxShadow`** - Full CSS box-shadow support including multiple shadows,
  spread, and inset. Accepts strings, objects, or arrays.
- **`filter`** - Graphical filters like `brightness`, `opacity`, `blur`,
  `contrast`, `grayscale`, `hueRotate`, `invert`, `saturate`, `sepia`, and
  `dropShadow`. Cross-platform for `brightness` and `opacity`; Android 12+ for
  others.
- **`mixBlendMode`** - Blend modes like `multiply`, `screen`, `overlay`, etc.
- **`isolation`** - Creates a new stacking context (`auto` | `isolate`)
- **`boxSizing`** - Box model (`border-box` | `content-box`)
- **`outlineColor`**, **`outlineStyle`**, **`outlineWidth`**, **`outlineOffset`** -
  Full outline support

These properties accept the same syntax on both platforms, and Tamagui
automatically handles the conversion between CSS strings (web) and object format
(native).

```tsx
// Works identically on web and native!
<View
  boxShadow="0 4px 12px $shadowColor"
  filter={[{ brightness: 1.1 }, { contrast: 0.9 }]}
/>

// Object syntax also supported
<View
  boxShadow={{
    offsetX: 0,
    offsetY: 4,
    blurRadius: 12,
    color: '$shadowColor',
  }}
/>
```

#### Colors

`@tamagui/colors` has been updated to Radix v3 colors (hex format). To preserve
backwards compatibility, existing v1-v4 theme configurations now use
`@tamagui/colors/legacy` which contains the original Radix v2 colors (HSL
format). Only v5 themes use the new colors.

If you have custom themes importing from `@tamagui/colors` and want to keep the
original colors, change your import to:

```tsx
import { blue, blueDark, ... } from '@tamagui/colors/legacy'
```

Things deprecated in version one that are now gone:

- Removed `space` and `spaceDirection` props in favor of gap.
- Moved the `<Spacer />` component from core into `@tamagui/spacer`.
- Moved all settings on `createTamagui` onto the `settings` object.

#### Animation Drivers

The Reanimated animation driver now supports `noRerender` mode, matching the
Motion driver. This means animations run entirely on the UI thread without
triggering React re-renders, giving you better performance for complex
animations.

#### React Compiler

All Tamagui packages are now built with the
[React Compiler](https://react.dev/learn/react-compiler), providing automatic
memoization for better runtime performance. The compiler analyzes your
components and automatically inserts `useMemo` and `useCallback` where
beneficial, reducing unnecessary re-renders without any code changes on your
part.

To use Tamagui with the React Compiler in your own app, you'll want to add the
`react-compiler-runtime` package as a dependency for React 18 compatibility:

```bash
npm install react-compiler-runtime
```

This runtime polyfill is required when using React 18 with code compiled by the
React Compiler. React 19 includes this runtime natively.

#### Headless and Unstyled Components

During v2 we're expanding headless components. Many components now have three
variants:

- **Styled** - Full Tamagui components with default styles
- **Unstyled** - Uses a `createX` factory allowing fully custom styling
- **Headless** - Zero dependency on `@tamagui/core`, just hooks

The headless packages (`@tamagui/switch-headless`, `@tamagui/checkbox-headless`,
`@tamagui/radio-headless`, `@tamagui/tabs-headless`) provide hooks like
`useSwitch`, `useCheckbox`, `useRadioGroup`, and `useTabs` that handle all the
state management, accessibility, and keyboard navigation - letting you bring
your own styling solution.

This makes Tamagui components usable even if you're not using Tamagui for
styling. For now it's a subset, but we plan to continue expanding headless
exports throughout v2.

#### New Components

We've added two new menu components that automatically adapt to each platform:

##### Menu

[Menu](/docs/components/menu) provides dropdown menus with full keyboard
navigation, submenus, checkbox items, and animations. On iOS and Android, it
automatically renders using native platform menus.

<HeroContainer>
  <MenuDemo />
</HeroContainer>

```tsx hero template=Menu

```

##### ContextMenu

[ContextMenu](/docs/components/context-menu) works like Menu but activates on
right-click (web) or long-press (native). It includes support for preview
content on iOS.

<HeroContainer>
  <ContextMenuDemo />
</HeroContainer>

```tsx hero template=ContextMenu

```

#### Component Scoping

Dialog, Popover, and Tooltip now support a `scope` prop that lets you mount a
single instance at your app's root while placing triggers anywhere in your tree.
This improves performance in lists or other sensitive areas since only the
lightweight Trigger renders inline.

```tsx
// _layout.tsx - mount once at root
<Tooltip scope="app">
  <Tooltip.Content>
    <Tooltip.Arrow />
  </Tooltip.Content>
  {children}
</Tooltip>

// anywhere else - just the trigger
<Tooltip.Trigger scope="app" aria-label="Settings">
  <Button icon={Settings} />
</Tooltip.Trigger>
```

### Goals

Our main goal with version two is **stability**. Tamagui started as a side
project with incredible scope and maintained an ambitious stance towards landing
large features and internal improvements.

Speaking for myself now: I personally pushed releases too fast, and as a result
burned too many of our users with regressions. We generally fast-followed with
fixes, but that isn't a good thing.

I'd like to sincerely apologize for the lack of rigor in our releases. We had a
version two nearly ready over a year ago and I felt we'd finally reached
maturity in terms of API, internals, performance, and general repo tooling, but
honestly, I just wanted to slow down, fix as many issues as possible, and find a
better balance.

I love Tamagui, it's always been something I do for the love of the game and not
profit. The company to date has made nearly half a million dollars and
re-invested all of it entirely to paying our team. We get amazing support, and I
really appreciate our community.

We've changed a lot over the last couple years to improve stability:

- Slowed down releases and added a variety of new checks to releases.
- Fixed nearly 1,000 issues.
- Improved our canary release process, and now use it much more often.
- Completed all the major re-writes we wanted to do, which let us finally focus
  on the above.

#### Testing

The testing infrastructure has been completely rebuilt since v1. At the v1.0
release we had 13 test files and a single CI workflow. Today we have 127 test
files across 5 testing frameworks with dedicated native testing infrastructure.

**Frameworks added:**

- **Playwright** for E2E and integration tests
- **Vitest** for unit and integration tests
- **Jest + Detox** for iOS and Android native E2E testing
- **Maestro** for iOS flow-based testing

**Multi-driver testing:** Every Playwright UI test runs three times - once each
with CSS, React Native, and Reanimated animation drivers. This catches
driver-specific regressions that would otherwise slip through.

**Platform-specific tests:** We now have separate test files for web, native,
and iOS-specific behavior (`*.web.test.tsx`, `*.native.test.tsx`,
`*.ios.test.tsx`), ensuring cross-platform correctness at the unit level.

**Native CI:** Two dedicated workflows handle native testing - one for Detox
E2E tests on both iOS and Android, and another for Maestro flow tests covering
components like Sheet, Select, Tabs, and Toast on real iOS simulators.

### What's next

Tamagui is quite mature in terms of features, foundation, and performance. We
likely won't add much for a while, instead I'd like to continue focusing on
refinement, and also move much more quickly towards a version three. That will
probably involve a version 2.X sometime soon that deprecates a variety more
things we want to, in order to clear the way.

Our broad goals for the future include better alignment to the web, simpler
onboarding, and potentially more familiar style APIs for people who aren't
Tamagui-pilled.
