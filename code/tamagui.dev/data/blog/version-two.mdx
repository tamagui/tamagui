---
title: Tamagui 2
publishedAt: '2025-12-29'
description: More stable, easier to use, better documented.
by: nate
poster: banner-two.jpg
---

<IntroParagraph large>
  Tamagui lets you build apps that share UI across React web and React Native
  without sacrificing quality, simplicity, or performance.
</IntroParagraph>

Tamagui is three things: a style library, an optimizing compiler, and a suite of
UI components. It's a vertically integrated solution with a lot of features,
hard-fought performance and testing, and AI agents can generate it with ease.

If you want, [skip to the new stuff in version two](#new-in-version-two).

### What and Why

You can skip this section if you are familiar with Tamagui already.

Tamagui brings many style features from CSS to native. Every style it supposrts
works on both native and web, at runtime and compile-time, and server-side and
client-side. It's SSR support is advanced without jumps or flickers, even when
using spring-based animation drivers, media queries, or themes. The optimizing
compiler unlocks natural inline styles, even when using abstracted styled
components or logic.

In comparison to other solutions, Tamagui is especially strong at:

- **Sharing between web and native without sacrifice.** Many other solutions
  focus on one platform more than others, or implement their features in sub-par
  ways on web, Tamagui has a large style featureset and hard-fought parity
  between platforms.
- **Great performance everywhere.** A small example - you can choose from 4
  animation drivers (CSS, Reanimated, Motion, React Native), per-platform, yet
  no matter which you choose proper SSR with media queries and dark mode
  properly renders and hydrates.
- **Fast, type-safe, mergeable inline styling.** Inline styles are a leap
  forward, but the lack of type safety or easy ability to merge and group your
  styles is their biggest drawback. Tamagui is fully type safe, lets you control
  how you merge styles, and optimizes it all nearly perfectly even in the face
  of complicated logic.
- **First-class, composable components based UI kit.** Our UI kit doesn't just
  target one platform, uses composable components, and can even adapt based on
  the device.
- **Well designed and robust.** It's been developed actively for many years,
  proven in [large apps](https://unsiwap.org), has a large test suite and
  extensive ecosystem.

Tamagui lets you do more with less. We're proud to be used by companies like
Uniswap to unify their featureset across platforms and greatly simplify their
codebase.

### Improvements During Version One

Tamagui improved continuously during version one. Some stats:

- **7,900+ commits** over 2 years (~330/month)
- **900+ issues closed**
- **136 new contributors** (from 46 to 182 total)
- **289 test files** with kitchen-sink tests running across all 4 animation
  drivers (256 test runs per CI), plus new native-specific tests with Detox and
  Maestro

Highlights:

- Created
  [`@tamagui/build`](https://github.com/tamagui/tamagui/blob/v2/code/packages/build/README.md),
  the only way to publish npm packages that support CommonJS and ESModules and
  native and web without requiring any configuration at all when importing -
  whether it's Metro, Node, Vite, or otherwise.
- Added many styling features like container queries, container and media
  queries combined, and platform/theme selectors.
- New compound components like Tabs, Accordion, and ToggleGroup.
- Unstyled versions of every component.
- Improved theme generation packages, and released a free visual Theme builder.
- The Takeout starter kit, and Bento copy-paste components and patterns.
- A lot of low level work on performance, documentation, our CLI, and more.

### New in Version Two

Version two is easy to migrate to with just a few breaking changes. It mostly
removes deprecated APIs, improves performance, aligns with modern React, React
Native, and web standards, and includes a few new features and components.

The breaking changes outside of deprecations are:

- **React Native 0.82+ and React 19+ required.** Tamagui 2 targets React Native
  0.82 and React 19 and above with New Architecture support. This enables
  significant new style features and simplifies internals.
- Default flex and position styles align with the latest React Native versions,
  but you can change settings to keep the legacy behavior.
- Button and ListItem lose direct text style props for better performance.
- useTheme no longer takes props; use the Theme component instead.
- Removed web-only `onHoverIn` and `onHoverOut` in favor of standard web events
  (`onMouseEnter` or `onPointerEnter`).
- Added comprehensive web event handler support including keyboard, pointer,
  drag and drop, clipboard, and scroll events.
- Moved from ThemeableStack to View for most base components in UI.
- Renamed the `animation` prop to `transition` for clarity and consistency.
- Removed `<Theme inverse />` and `themeInverse` prop - see
  [inverse themes guide](/docs/guides/theme-builder#inverse-themes).
- Removed the `maxDarkLightNesting` and `cssStyleSeparator` settings.
- Removed `space` and `spaceDirection` props - use `gap` instead.
- Moved `<Spacer />` from core to `@tamagui/spacer`.
- Moved all settings on `createTamagui` to the `settings` object.

#### CSS Shorthand with Variables

You can now use Tamagui `$variables` directly inside CSS shorthand string values
like `boxShadow`. On web, variables resolve to CSS custom properties; on native,
they resolve to raw values:

```tsx
// Works on both web and native!
<View boxShadow="0 0 10px $shadowColor" />

// Multiple variables work too
<View boxShadow="0 0 5px $shadowColor, 0 0 15px $color" />
```

The `border` shorthand with variables (`border="1px solid $borderColor"`) is
web-only since React Native doesn't support CSS border shorthand syntax. On
native, continue using the individual props (`borderWidth`, `borderColor`,
`borderStyle`).

#### Cross-Platform Style Props

Many style properties that were previously web-only now work on React Native
with the New Architecture:

- **`boxShadow`** - Full CSS box-shadow support including multiple shadows,
  spread, and inset. Accepts strings, objects, or arrays.
- **`filter`** - Graphical filters like `brightness`, `opacity`, `blur`,
  `contrast`, `grayscale`, `hueRotate`, `invert`, `saturate`, `sepia`, and
  `dropShadow`. Cross-platform for `brightness` and `opacity`; Android 12+ for
  others.
- **`mixBlendMode`** - Blend modes like `multiply`, `screen`, `overlay`, etc.
- **`isolation`** - Creates a new stacking context (`auto` | `isolate`)
- **`boxSizing`** - Box model (`border-box` | `content-box`).
- **`display`** - Pass-through with `contents`.

These properties accept the same syntax on both platforms, and Tamagui
automatically handles the conversion between CSS strings (web) and object format
(native).

```tsx
// Works identically on web and native!
<View
  boxShadow="0 4px 12px $shadowColor"
  filter={[{ brightness: 1.1 }, { contrast: 0.9 }]}
/>

// Object syntax also supported
<View
  boxShadow={{
    offsetX: 0,
    offsetY: 4,
    blurRadius: 12,
    color: '$shadowColor',
  }}
/>
```

#### Colors

`@tamagui/colors` has been updated to Radix v3 colors (hex format). To preserve
backwards compatibility, existing v1-v4 theme configurations now use
`@tamagui/colors/legacy` which contains the original Radix v2 colors (HSL
format). Only v5 themes use the new colors.

If you have custom themes importing from `@tamagui/colors` and want to keep the
original colors, change your import to:

```tsx
import { blue, blueDark, ... } from '@tamagui/colors/legacy'
```

#### Motion Animation Driver

We've added a new [animation driver](/docs/core/animations) powered by
[Motion](https://motion.dev), and it's our recommended choice for web. The
`@tamagui/animations-motion` package brings excellent performance through some
key architectural decisions.

The Motion driver avoids React re-renders entirely during animations. When
styles change, instead of triggering a re-render cycle, it directly mutates the
DOM through Motion's `useAnimate` hook. This is enabled by a rewrite of Tamagui
internals to allow a new `avoidReRenders` setting for animation drivers, which
tells Tamagui's core to emit style changes via a callback rather than through
state updates.

Under the hood, Motion leverages the
[Web Animations API (WAAPI)](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API),
which runs animations off the main thread. This means your spring animations run
at 60fps even when JavaScript is busy. The driver also implements intelligent
diffing - it tracks the previous animated styles and only sends changed
properties to Motion, minimizing work on each frame.

The result is buttery smooth animations that don't block your UI, making it
ideal for complex interactive components like sheets, popovers, and page
transitions on web.

#### Reanimated Driver Improvements

The Reanimated animation driver now supports `avoidReRenders`, matching the
Motion driver. This means animations run entirely on the UI thread without
triggering React re-renders, giving you much better performance for complex
animations on both web and native.

The Moti driver (`@tamagui/animations-moti`) is now deprecated in favor of the
Reanimated driver (`@tamagui/animations-reanimated`). This removes a dependency
and fixes some compatibility issues. If you're using `@tamagui/animations-moti`,
switch to `@tamagui/animations-reanimated` - the API is the same.

#### Per-Component Animation Drivers

You can now configure multiple animation drivers and select per-component using
the new `animatedBy` prop:

```tsx
// Config with multiple drivers
createTamagui({
  animations: {
    default: cssDriver,
    spring: reanimatedDriver,
  },
})

// Select per-component
<View animatedBy="spring" transition="bouncy" />
```

For lazy loading drivers (e.g., load a heavier driver only after login), use the
new `loadAnimationDriver` function:

```tsx
import { loadAnimationDriver } from 'tamagui'
loadAnimationDriver('spring', reanimatedDriver)
```

#### Transition Delay

All animation drivers now support delays:

```tsx
<View transition={['bouncy', { delay: 200 }]} />
```

This works with CSS, React Native Animated, Reanimated, and Motion drivers.

#### Popover Transform Origin

[Popover](/docs/components/popover) and [Tooltip](/docs/components/tooltip) now
automatically calculate the correct CSS `transform-origin` based on placement
and arrow position. This means scale animations naturally "grow" from the anchor
point where the content connects to the trigger.

The transform origin adjusts automatically based on the final placement - if the
popover flips from `bottom` to `top`, the origin updates accordingly. This
creates polished, native-feeling animations without any manual configuration.

#### Headless and Unstyled Components

We're expanding headless components in v2. Many components now have three
variants:

- **Styled** - Full Tamagui components with default styles
- **Unstyled** - Uses a `createX` factory allowing fully custom styling
- **Headless** - Zero dependency on `@tamagui/core`, just hooks

The headless packages (`@tamagui/switch-headless`, `@tamagui/checkbox-headless`,
`@tamagui/radio-headless`, `@tamagui/tabs-headless`) provide hooks like
`useSwitch`, `useCheckbox`, `useRadioGroup`, and `useTabs` that handle all the
state management, accessibility, and keyboard navigation - letting you bring
your own styling solution.

This makes Tamagui components usable even if you're not using Tamagui for
styling. For now it's a subset, but we plan to continue expanding headless
exports throughout v2.

#### @tamagui/react-native-web-lite

React Native Web has slowed down development and has various issues in modern JS
projects. We built `@tamagui/react-native-web-lite` by translating
`react-native-web` to TypeScript, moving to a modern ESModule setup, and
enabling tree shaking.

If you're using Tamagui for most styling, you can save a significant amount of
bundled JS on web by aliasing to this package. It's not perfectly compatible
with `react-native-web` - it strips out the style system to share Tamagui
internals - but for Tamagui-first apps, it's a nice optimization.

#### Component Scoping

Dialog, Popover, and Tooltip now support a `scope` prop that lets you mount a
single instance at your app's root while placing triggers anywhere in your tree.
This is a significant performance win - in testing with large apps, we found it
greatly improved UX by eliminating the overhead of mounting full overlay
components inline.

Instead of each Tooltip or Popover in a list rendering its own portal, content,
and animation logic, you mount one instance at the root and scatter lightweight
triggers throughout your app. The triggers are just simple components that
communicate with the shared instance via context.

```tsx
// _layout.tsx - mount once at root
<Tooltip scope="app">
  <Tooltip.Content>
    <Tooltip.Arrow />
  </Tooltip.Content>
  {children}
</Tooltip>

// anywhere else - just the trigger
<Tooltip.Trigger scope="app" aria-label="Settings">
  <Button icon={Settings} />
</Tooltip.Trigger>
```

This pattern is especially valuable for data-heavy views like tables, lists, or
dashboards where you might have dozens or hundreds of interactive elements that
need tooltips or popovers.

#### New Components

##### Input & TextArea

<HeroContainer demoMultiple>
  <NewInputsDemo />
</HeroContainer>

```tsx hero template=Inputs

```

The v2 Input takes a web-first approach - you write standard HTML input
attributes and Tamagui automatically converts them to React Native equivalents
on native platforms:

```tsx
// Web-standard API that works everywhere
<Input type="email" enterKeyHint="send" />
<Input type="password" />
<Input type="tel" />
```

This replaces the React Native-style props like `keyboardType`,
`secureTextEntry`, and `returnKeyType` with their web equivalents. The old props
still work but are deprecated. See the [Input docs](/docs/components/inputs) for
the full migration guide.

##### Image

The [Image](/docs/components/image) component follows the same web-first
philosophy as Input. It uses standard HTML `<img>` attributes like `src`, `alt`,
`loading`, and `decoding` as the primary API, with automatic conversion to React
Native equivalents on native.

On native, you can choose your image loading adapter - use the built-in React
Native Image, or integrate with optimized libraries like `expo-image` or
`react-native-fast-image` for better caching and performance.

##### Menu

[Menu](/docs/components/menu) provides dropdown menus with full keyboard
navigation, submenus, checkbox items, and animations. On iOS and Android, it
automatically renders using native platform menus.

<HeroContainer>
  <MenuDemo />
</HeroContainer>

```tsx hero template=Menu

```

##### ContextMenu

[ContextMenu](/docs/components/context-menu) works like Menu but activates on
right-click (web) or long-press (native). It includes support for preview
content on iOS.

<HeroContainer>
  <ContextMenuDemo />
</HeroContainer>

```tsx hero template=ContextMenu

```

### Goals

Our main goal with version two is **stability**. Tamagui started as a side
project with incredible scope and maintained an ambitious stance towards landing
large features and internal improvements.

Speaking for myself now: I personally pushed releases too fast, and as a result
burned too many of our users with regressions. We generally fast-followed with
fixes, but that isn't good enough.

I'd like to sincerely apologize for the lack of rigor in our releases. We had a
version two nearly ready over a year ago and I felt we'd finally reached
maturity in terms of API, internals, performance, and general repo tooling, but
honestly, I just wanted to slow down, fix as many issues as possible, and find a
better balance.

I love Tamagui, it's always been something I do for the love of the game and not
profit. The company has made nearly half a million dollars to date and
re-invested all of it into paying our team. We get amazing support, and I really
appreciate our community.

We've changed a lot over the last couple years to improve stability:

- Landed many new tests and far more robust native test suite that tests both
  functionality and style.
- Slowed down releases and added a many more code-quality and package-quality
  checks to releases.
- Made our canary release easier, and now use it much more often.
- Generally completed many major re-writes we wanted to do.

#### Testing

The testing infrastructure has been completely rebuilt since v1. At the v1.0
release we had 13 test files and a single CI workflow. Today we have 127 test
files across 5 testing frameworks with dedicated native testing infrastructure.

**Frameworks added:**

- **Playwright** for E2E and integration tests
- **Vitest** for unit and integration tests
- **Jest + Detox** for iOS and Android native E2E testing
- **Maestro** for iOS flow-based testing

**Multi-driver testing:** Every Playwright UI test runs four times, once for
each animation driver. This catches driver-specific regressions that would
otherwise slip through.

### What's next

Tamagui is quite mature in terms of features, foundation, and performance. We
likely won't add much for a while, instead I'd like to continue focusing on
refinement, and also move much more quickly towards a version three. That will
probably involve a version 2.X sometime soon that deprecates a variety more
things we want to, in order to clear the way.

Our broad goals for the future include better alignment to the web, simpler
onboarding, and a few more components.

### Thanks

A huge thanks is owed to our amazing team, which has persisted through this
giant release and throughout the last two years fixing issues.

Special thanks to [Quan Nguyen](https://github.com/anhquan291)
([@LionelNguyen19](https://x.com/LionelNguyen19)) for extensive work on Takeout
documentation, Radix v3 color updates, and theme improvements. And to
[Dave Mkpa-Eke](https://github.com/DaveyEke)
([@1804davey](https://x.com/1804davey)) for numerous bug fixes across Progress,
Input, ContextMenu, and other components, as well as the new Select.Indicator
feature and blog improvements.
