---
title: Tamagui 2
publishedAt: '2025-12-29'
description: Stability, ease of use, docs, and new components.
by: nate
image: /blog/version-two.webp
---

<IntroParagraph large>
  Tamagui makes cross-platform React styling fast, easy, and feature-complete.
  Its optimizing compiler turns logical, typed, inline styles into optimally
  performant output. Plus, a huge ecosystem of components, themes, copy-paste
  UI, and starters.
</IntroParagraph>

We're excited to announce that the release candidate of **Tamagui v2 is here**!

If you want to: [skip to what's new](#new-in-v2)...

### Background

Tamagui brings many style features from CSS to native. Every style it supports
works on both native and web, at both run-time and compile-time, and server-side
as well as client-side.

In comparison to other solutions, Tamagui is especially strong at:

- **Sharing between web and native without sacrifice.** Many other solutions
  focus on one platform more than others, or implement their features in sub-par
  ways on web, Tamagui has a large style featureset and hard-fought parity
  between platforms.
- **Great performance everywhere.** A small example - you can choose from 4
  animation drivers (CSS, Reanimated, Motion, React Native), per-platform, yet
  no matter which you choose proper SSR support even with media queries and dark
  mode properly rendering and hydrating without jumps or flickers.
- **Fast, type-safe, mergeable inline styling.** Inline styles are a leap
  forward, but the lack of type safety or easy ability to merge and group your
  styles is their biggest drawback. Tamagui is fully type safe, lets you control
  how you merge styles, and optimizes it all nearly perfectly even in the face
  of complicated logic.
- **First-class, composable components based UI kit.** Our UI kit doesn't just
  target one platform, uses composable components, and can even adapt based on
  the device.
- **Well designed and robust.** It's been developed actively for many years,
  proven in [large apps](https://uniswap.org), has a large test suite and
  extensive ecosystem.

Tamagui lets you do more with less. We're proud to be used by companies like
Uniswap to unify their featureset across platforms and greatly simplify their
codebase.

### In the last two years

Some highlights:

- **7,900+ commits** over 2 years (~330/month).
- **900+ issues closed**.
- **136 new contributors** (from 46 to 182 total).
- **289 test files** with kitchen-sink tests running across all 4 animation
  drivers (256 test runs per CI), plus new native-specific tests with Detox and
  Maestro.
- Created
  [`@tamagui/build`](https://github.com/tamagui/tamagui/blob/v2/code/packages/build/README.md),
  the only way to publish npm packages that support CommonJS and ESModules and
  native and web without requiring any configuration at all when importing -
  whether it's Metro, Node, Vite, or otherwise.
- Added many styling features like container queries, container and media
  queries combined, and platform/theme selectors.
- New compound components like Tabs, Accordion, and ToggleGroup.
- Unstyled versions of most components.
- Improved theme generation packages, and the amazing
  [free and paid theme builder](/theme).

[![Theme Generator examples](/blog/theme-generator-showcase.webp)](/theme/37/nike-neon)

- The Takeout starter kit, and Bento copy-paste components and patterns.
- A lot of low level work on performance, documentation, our CLI, and more.

## New in v2

Version two is easy to migrate to with just a few breaking changes. It mostly
removes deprecated APIs, improves performance, aligns with modern React, React
Native, and web standards, and includes a few new features and components.

The breaking changes outside of deprecations are:

- **Removed deprecated v2 config exports.** The `/v2` exports from
  `@tamagui/config`, `@tamagui/themes`, and `@tamagui/shorthands` have been
  removed. These were the original config format from early Tamagui versions -
  not to be confused with Tamagui v2 itself. The current config is now at v5. If
  you were using `@tamagui/config/v2`, migrate to `@tamagui/config/v5` or the
  default export.

- **React Native 0.82+, React 19+, and TypeScript 5+ required.** Tamagui 2
  targets React Native 0.82, React 19, and TypeScript 5 and above with New
  Architecture support. This enables significant new style features, improved
  type inference, and simplified internals.
- Default flex and position styles align with the latest React Native versions,
  but you can change settings to keep the legacy behavior.
- Button and ListItem lose direct text style props for better performance.
- useTheme no longer takes props; use the Theme component instead.
- Removed web-only `onHoverIn` and `onHoverOut` in favor of standard web events
  (`onMouseEnter` or `onPointerEnter`).
- Added comprehensive web event handler support including keyboard, pointer,
  drag and drop, clipboard, and scroll events.
- Moved from ThemeableStack to View for most base components in UI.
- Removed deprecated `Stack` for the identical `View`.
- Renamed the `animation` prop to `transition` for clarity and consistency.
- Removed `<Theme inverse />` and `themeInverse` prop - see
  [inverse themes guide](/docs/guides/theme-builder#inverse-themes).
- Removed the `maxDarkLightNesting` and `cssStyleSeparator` settings.
- Removed `space` and `spaceDirection` props - use `gap` instead.
- Tabs `activationMode` now defaults to `'manual'` instead of `'automatic'`.
  This means focusing a tab no longer changes the active tab - you must click or
  press Enter/Space. This matches web standards.
- Group component simplified: `Group.Item` is now required (no more auto-cloning
  direct children). Removed props: `space`, `separator`, `scrollable`,
  `showScrollIndicator`, `disablePassBorderRadius`, `forceUseItem`. Children now
  control their own sizing - apply size/responsive props directly to child
  components. Add `<Separator />` manually between items when needed.
- Moved `<Spacer />` from core to `@tamagui/spacer`.
- Moved all settings on `createTamagui` to the `settings` object.
- Native portals no longer auto-import React internals hack. If you want native
  portals for better context preservation, call `setupNativePortal()` from
  `@tamagui/portal/setup-native` at app startup. See
  [Portal docs](/docs/components/portal).
- Removed React Native accessibility props in favor of web-standard props:
  - `accessibilityLabel` → `aria-label`
  - `accessibilityRole` → `role`
  - `accessibilityHint` → `aria-describedby`
  - `accessibilityState` → `aria-disabled`, `aria-selected`, `aria-checked`,
    `aria-busy`, `aria-expanded`
  - `accessibilityValue` → `aria-valuemin`, `aria-valuemax`, `aria-valuenow`,
    `aria-valuetext`
  - `accessibilityElementsHidden` → `aria-hidden`
  - `accessibilityViewIsModal` → `aria-modal`
  - `accessibilityLiveRegion` → `aria-live`
  - `accessible` → `tabIndex={0}`
  - `focusable` → `tabIndex`
  - `nativeID` → `id`

<Notice>
  Copy this blog post to give to AI Agents to migrate from v1 to v2!
</Notice>

### Features

#### Cross-Platform Style Props

Many style properties that were previously web-only now work on React Native
with the New Architecture. See the [Style API docs](/docs/intro/styles) for the
full reference.

- **`boxShadow`** - Full CSS box-shadow support including multiple shadows,
  spread, and inset. Accepts strings, objects, or arrays.
- **`filter`** - Graphical filters like `brightness`, `opacity`, `blur`,
  `contrast`, `grayscale`, `hueRotate`, `invert`, `saturate`, `sepia`, and
  `dropShadow`. Cross-platform for `brightness` and `opacity`; Android 12+ for
  others.
- **`mixBlendMode`** - Blend modes like `multiply`, `screen`, `overlay`, etc.
- **`isolation`** - Creates a new stacking context (`auto` | `isolate`)
- **`boxSizing`** - Box model (`border-box` | `content-box`).
- **`display`** - Pass-through with `contents`.
- **`position`** - Now accepts `fixed` on native, automatically converted to
  `absolute`. This lets you write cross-platform code with media queries like
  `$md={{ position: 'fixed' }}` that works everywhere.
- **`borderCurve`** - Corner curve style (`circular` | `continuous` for Apple's
  "squircle"). iOS 13+ only.
- **`cursor`** - Cursor style. Full CSS values on web; `auto` | `pointer` on iOS
  17+ (trackpad/stylus).

#### CSS Shorthands with Variables

You can now use Tamagui `$variables` directly inside CSS shorthand string values
like `boxShadow`. On web, variables resolve to CSS custom properties; on native,
they resolve to raw values:

```tsx
// Works on both web and native!
<View boxShadow="0 0 10px $shadowColor" />

// Multiple variables work too
<View boxShadow="0 0 5px $shadowColor, 0 0 15px $color" />
```

The `border` shorthand with variables (`border="1px solid $borderColor"`) is
web-only since React Native doesn't support CSS border shorthand syntax. On
native, continue using the individual props (`borderWidth`, `borderColor`,
`borderStyle`).

#### Motion Animation Driver

![Motion animation library banner](/blog/motion-banner.webp)

We've added a new [animation driver](/docs/core/animations) powered by
[Motion](https://motion.dev), and it's our recommended choice for web. The
`@tamagui/animations-motion` package is fast thanks to two optimizations:

- **No re-renders**: Tamagui now supports an `avoidReRenders` mode for animation
  drivers. Instead of updating state, style changes flow through a callback that
  mutates the DOM directly.
- **Off main thread**: Motion uses the
  [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API),
  which runs animations off the main JavaScript thread.

Together these make for much smoother spring animations on web.

#### Reanimated Driver Improvements

The [Reanimated](https://docs.swmansion.com/react-native-reanimated/) driver
comes back in style with `worklet` and `avoidReRenders` support. This means
animations run entirely on the UI thread without triggering React re-renders,
giving you much better performance for complex animations on both web and
native.

The Moti driver (`@tamagui/animations-moti`) is now deprecated in favor of the
Reanimated driver (`@tamagui/animations-reanimated`). This removes a dependency
and fixes some compatibility issues. If you're using `@tamagui/animations-moti`,
switch to `@tamagui/animations-reanimated` - the API is the same.

#### Per-Component Animation Drivers

You can now configure multiple animation drivers and select per-component using
the new `animatedBy` prop. This serves two important purposes: it allows mixing
drivers more granularly, and it enables the compiler to better optimize.

```tsx
// Config with multiple drivers up front
createTamagui({
  animations: {
    default: cssDriver,
    spring: reanimatedDriver,
  },
})

// Select per-component - compiler can optimize knowing the driver
<View animatedBy="spring" transition="bouncy" />
```

When the compiler sees `animatedBy`, it can make smarter decisions about
extraction and avoid including unnecessary animation runtime code for components
that don't need it. You can also lazy load a driver (e.g., load a heavier driver
only after login), use the new `loadAnimationDriver` function, similar to how
you could before using Configuration:

```tsx
import { loadAnimationDriver } from 'tamagui'
loadAnimationDriver('spring', reanimatedDriver)
```

#### Transition Delay

All animation drivers now support delays:

```tsx
<View transition={['bouncy', { delay: 200 }]} />
```

This works with CSS, React Native Animated, Reanimated, and Motion drivers.

#### Enter/Exit Transitions

The `transition` prop now supports different animations for enter and exit. This
is useful for creating asymmetric animations where elements enter slowly but
exit quickly, or vice versa:

```tsx
// slow enter, fast exit
<View
  transition={{ enter: 'lazy', exit: 'quick' }}
  enterStyle={{ opacity: 0 }}
  exitStyle={{ opacity: 0 }}
/>

// with a default for property changes while mounted
<View
  transition={{ enter: 'lazy', exit: 'quick', default: 'bouncy' }}
/>

// array syntax with delay and per-property config
<View
  transition={['bouncy', { enter: 'lazy', exit: 'quick', delay: 200 }]}
/>
```

This works across all four animation drivers. See the
[animation docs](/docs/core/animations#enterexittransitions) for more details.

#### Popover Transform Origin

[Popover](/docs/components/popover) and [Tooltip](/docs/components/tooltip) now
automatically calculate the correct CSS `transform-origin` based on placement
and arrow position. This means scale animations naturally "grow" from the anchor
point where the content connects to the trigger.

The transform origin adjusts automatically based on the final placement - if the
popover flips from `bottom` to `top`, the origin updates accordingly. This
creates polished, native-feeling animations without any manual configuration.

#### Active State Styling

Components with toggle/selection states now support consistent `activeStyle` and
`activeTheme` props for styling their active states:

- **Switch** - Styles applied when the switch is on
- **Checkbox** - Styles applied when checked
- **ToggleGroup.Item** - Styles applied when the item is selected
- **Tabs.Tab** - Styles applied when the tab is active

```tsx
// Apply custom styles when active
<Switch activeStyle={{ backgroundColor: '$green8' }} />

// Or apply a theme when active
<Checkbox activeTheme="green" />

// Works inline or via styled()
const GreenTab = styled(Tabs.Tab, {
  activeStyle: {
    backgroundColor: '$green9',
  },
})
```

This replaces the inconsistent methods of active styling found across components
in v1.

#### Component Cleanups

Several components have been significantly simplified:

**Button** - Rewritten from scratch with ~60% less code. No longer uses the slow
`useProps` hook internally. Now supports all web-standard HTML button attributes
(`type`, `formAction`, `formMethod`, `name`, `value`, `popoverTarget`, etc.).
Defaults to `type="button"` to prevent accidental form submissions.

**ListItem** - Rebuilt with context-based styling. Removed text style props
(`fontFamily`, `fontSize`, etc.) and internal spacing props (`spaceFlex`,
`scaleSpace`) for composable component API. Much faster rendering.

**Select** - SelectItem is based on ListItem so is likewise much faster, and
gains an optional floating indicator. SelectLabel is now a simpler
SizableText-based component instead of depending on ListItem.

**Tabs** - `activeStyle` and `activeTheme` props replace the old `Theme` wrapper
approach. `activationMode` now defaults to `'manual'` (click/Enter to activate)
matching web standards.

**Groups** - Dramatically simplified. No more magic child cloning.

#### Headless and Unstyled Components

We're expanding headless components in v2. Many components now have three
variants:

- **Styled** - Full Tamagui components with default styles
- **Unstyled** - Uses a `createX` factory allowing fully custom styling
- **Headless** - Zero dependency on `@tamagui/core`, just hooks

The headless packages (`@tamagui/switch-headless`, `@tamagui/checkbox-headless`,
`@tamagui/radio-headless`, `@tamagui/tabs-headless`) provide hooks like
`useSwitch`, `useCheckbox`, `useRadioGroup`, and `useTabs` that handle all the
state management, accessibility, and keyboard navigation - letting you bring
your own styling solution.

This makes Tamagui components usable even if you're not using Tamagui for
styling. For now it's a subset, but we plan to continue expanding headless
exports throughout v2.

#### @tamagui/react-native-web-lite

React Native Web has slowed down development and has various issues in modern JS
projects. We built `@tamagui/react-native-web-lite` by translating
`react-native-web` to TypeScript, moving to a modern ESModule setup, and
enabling tree shaking.

If you're using Tamagui for most styling, you can save a significant amount of
bundled JS on web by aliasing to this package. It's not perfectly compatible
with `react-native-web` - it strips out the style system to share Tamagui
internals - but for Tamagui-first apps, it's a nice optimization.

#### Component Scoping

Dialog, Popover, Sheet, and Tooltip now support a `scope` prop that lets you
mount a single instance at your app's root while placing triggers anywhere in
your tree. **This is a significant performance win** - in testing with large
apps, we found it greatly improved UX by eliminating the overhead of mounting
full overlay components inline.

Instead of each Tooltip or Popover in a list rendering its own portal, content,
and animation logic, you mount one instance at the root and scatter lightweight
triggers throughout your app. The triggers are just simple components that
communicate with the shared instance via context.

```tsx
// _layout.tsx - mount once at root with your providers
<TamaguiProvider>
  <Tooltip scope="global">
    <Tooltip.Content>
      <Tooltip.Arrow />
      <Paragraph>{/* label set by trigger */}</Paragraph>
    </Tooltip.Content>

    {/* rest of your app */}
    <Slot />
  </Tooltip>
</TamaguiProvider>

// anywhere in your app - just the trigger
<Tooltip.Trigger scope="global" aria-label="Settings">
  <Button icon={Settings} />
</Tooltip.Trigger>
```

This pattern is especially valuable for data-heavy views like tables, lists, or
dashboards where you might have dozens or hundreds of interactive elements that
need tooltips or popovers.

#### Colors

`@tamagui/colors` has been updated to Radix v3, old colors are available at
`@tamagui/colors/legacy`.

#### Native Compiler Improvements

The native compiler has been significantly improved in v2. Most notably, the
experimental theme optimization setting is now on by default, and stable. This
means better performance on native without any configuration needed.

#### Native Portals

Tamagui's portal-based components (Sheet, Dialog, Popover, Select, and Toast)
now support true native portals via
[react-native-teleport](https://github.com/nicksrandall/react-native-teleport).

The problem: on native, the default portal implementation doesn't preserve React
context. Tamagui automatically re-propagates its own contexts (theme,
configuration), but your custom contexts like navigation or app state aren't
available inside portaled content. The re-propagation also adds overhead.

The solution: call `setupNativePortal()` once at app startup:

```tsx
import { setupNativePortal } from '@tamagui/portal/setup-native'

setupNativePortal()
```

This tells Tamagui to use the teleport package for true native portal
functionality, preserving the React fiber tree so all context flows through
automatically. No more manually re-propagating theme context or navigation state
into your sheets and dialogs.

See the [Portal docs](/docs/components/portal) for full details and alternative
approaches like component scoping.

### New Components

#### Input & TextArea

<HeroContainer demoMultiple>
  <NewInputsDemo />
</HeroContainer>

```tsx hero template=Inputs

```

Input has been rewritten from scratch with a web-first approach - you write
standard HTML input attributes and Tamagui automatically converts them to React
Native equivalents on native platforms:

```tsx
// Web-standard API that works everywhere
<Input type="email" enterKeyHint="send" />
<Input type="password" />
<Input type="tel" />
```

This replaces the React Native-style props like `keyboardType`,
`secureTextEntry`, and `returnKeyType` with their web equivalents. The old props
still work but are deprecated. See the [Input docs](/docs/components/inputs) for
the full migration guide.

#### Image

The [Image](/docs/components/image) component follows the same web-first
philosophy as Input. It uses standard HTML `<img>` attributes like `src`, `alt`,
`loading`, and `decoding` as the primary API, with automatic conversion to React
Native equivalents on native.

On native, you can choose your image loading adapter - use the built-in React
Native Image, or integrate with optimized libraries like `expo-image` or
`react-native-fast-image` for better caching and performance.

#### Menu

[Menu](/docs/components/menu) provides dropdown menus with full keyboard
navigation, submenus, checkbox items, and animations. On iOS and Android, it
automatically renders using native platform menus.

<HeroContainer>
  <MenuDemo />
</HeroContainer>

```tsx hero template=Menu

```

#### ContextMenu

[ContextMenu](/docs/components/context-menu) works like Menu but activates on
right-click (web) or long-press (native). It includes support for preview
content on iOS.

<HeroContainer>
  <ContextMenuDemo />
</HeroContainer>

```tsx hero template=ContextMenu

```

#### CLI Improvements / Agent Docs Generation

The [Tamagui CLI](/docs/guides/cli) has new commands for building and working
with your design system:

- **`tamagui build`** - Pre-compile components in-place for production. Works
  with any bundler and supports wrapping your build command to automatically
  restore files after.
- **`tamagui generate`** - Build your full Tamagui configuration and output CSS.
  Validates your config and pre-generates your design system.
- **`tamagui generate-css`** - Generate the `tamagui.css` file from your config.
  Use `--output` to specify a custom output path.
- **`tamagui generate-prompt`** - Generate an LLM-friendly markdown file from
  your config, documenting all tokens, themes, components, and shorthands for
  use with AI assistants.
- **`tamagui check`** - Scan for inconsistent dependency versions across your
  project.

We recommend generating your prompt and committing to your repo, even before you
do your full upgrade to version 2, as it will help agents understand your
Tamagui config better.

### Goals

Our main goal with version two is **stability**. Tamagui started as a side
project with incredible scope and maintained an ambitious stance towards landing
large features and internal improvements.

Speaking for myself now: I personally pushed releases too fast, and as a result
burned too many of our users with regressions. We generally fast-followed with
fixes, but that isn't good enough.

I'd like to apologize for that, sincerely. We had a v2 nearly ready over a year
ago, but it felt right to push back the release until we felt confident we'd
fixed nearly every major issue, and overhauled our testing setup.

React Native is difficult to test, so it took us a while to build it out, but
I'm incredibly happy with where we're at now. On every commit we're running
integration tests on iOS and Android across every complex component, alongside a
few thousand web and core tests.

#### Testing

The testing infrastructure has been completely rebuilt since v1. At the v1.0
release we had 13 test files and a single CI workflow. Today we have 127 test
files across 5 testing frameworks with dedicated native testing infrastructure.

**Frameworks added:**

- **Playwright** for E2E and integration tests
- **Vitest** for unit and integration tests
- **Jest + Detox** for iOS and Android native E2E testing
- **Maestro** for iOS flow-based testing

**Multi-driver testing:** Every Playwright UI test runs four times, once for
each animation driver. This catches driver-specific regressions that would
otherwise slip through.

### What's next

Tamagui is quite mature in terms of features, foundation, and performance. AI
Agents generate its code exceptionally well because it's been in wide use and
well documented for years. For this reason, we are avoiding large syntax or
theme changes, for now.

We're going to deprecate a variety of things in 2.1 that will be planned for
3.0, and will follow with 3.0 a lot quicker than this major took.

There's still some work to do in terms of simplifying internals, we'd like to
move both our built-in styles and standardized sizing to be done in a more clear
way where it's easy to unplug either. Other broad goals include better alignment
to the web, simpler onboarding, more components, better components, and more
native component integrations.

### Thanks

A huge thanks is owed to our amazing team, which has persisted through this
giant release and throughout the last two years fixing issues.

Special thanks to [Quan Nguyen](https://github.com/anhquan291)
([@LionelNguyen19](https://x.com/LionelNguyen19)) for extensive work on Takeout
documentation, Radix v3 color updates, and theme improvements. And to
[Dave Mkpa-Eke](https://github.com/DaveyEke)
([@1804davey](https://x.com/1804davey)) for numerous bug fixes across Progress,
Input, ContextMenu, and other components, as well as the new Select.Indicator
feature and blog improvements.

---

### Consulting

We're also testing out consulting this year through
**[Add Even](https://addeven.com)**. We built a production app for a company
late last year in record time — three weeks from start to approval in app stores
— and that was before we spent the last few months refining everything based on
that project.

If you'd like to launch something in record time that's as ambitious as
possible, and is beautiful inside and out — please do
[get in touch](https://addeven.com).
