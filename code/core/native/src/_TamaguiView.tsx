import type React from 'react'
import { createElement, useCallback, useEffect, useRef, useContext } from 'react'
import { View, type ViewProps, type ViewStyle } from 'react-native'

// conditional import for native-style-registry
let registry: typeof import('@tamagui/native-style-registry') | undefined
try {
  registry = require('@tamagui/native-style-registry')
} catch {
  // package not installed, use JS-only mode
}

// fallback to useThemeName when native registry not available
let useThemeName: () => string = () => 'light'
try {
  const core = require('@tamagui/core')
  useThemeName = core.useThemeName
} catch {
  // @tamagui/core not available
}

interface DeduplicatedStyle extends ViewStyle {
  // array of theme names that share this style (for deduplication)
  __themes?: string[]
}

export interface TamaguiViewProps extends ViewProps {
  /**
   * Pre-computed styles for each theme, keyed by theme name.
   * Generated by the compiler at build time.
   * Styles may be deduplicated with __themes array listing all theme names
   * that share the same style.
   */
  __styles?: Record<string, DeduplicatedStyle>
}

// cache for theme -> style lookup to avoid repeated __themes searches
const styleCache = new WeakMap<
  Record<string, DeduplicatedStyle>,
  Map<string, ViewStyle | undefined>
>()

/**
 * Find the style for a theme name from deduplicated __styles.
 * Styles can be keyed directly by theme name OR found via __themes array.
 */
function findStyleForTheme(
  styles: Record<string, DeduplicatedStyle>,
  themeName: string
): ViewStyle | undefined {
  // check cache first
  let themeCache = styleCache.get(styles)
  if (themeCache?.has(themeName)) {
    return themeCache.get(themeName)
  }

  // direct lookup
  if (styles[themeName]) {
    const style = styles[themeName]
    // return style without __themes metadata
    const { __themes, ...cleanStyle } = style
    cacheResult(styles, themeName, cleanStyle)
    return cleanStyle
  }

  // search through __themes arrays
  for (const [key, style] of Object.entries(styles)) {
    if (style.__themes?.includes(themeName)) {
      const { __themes, ...cleanStyle } = style
      cacheResult(styles, themeName, cleanStyle)
      return cleanStyle
    }
  }

  // theme not found, try fallback to base theme (e.g., "dark_blue" -> "dark")
  const baseParts = themeName.split('_')
  if (baseParts.length > 1) {
    const baseTheme = baseParts[0]
    return findStyleForTheme(styles, baseTheme)
  }

  cacheResult(styles, themeName, undefined)
  return undefined
}

function cacheResult(
  styles: Record<string, DeduplicatedStyle>,
  themeName: string,
  result: ViewStyle | undefined
) {
  let themeCache = styleCache.get(styles)
  if (!themeCache) {
    themeCache = new Map()
    styleCache.set(styles, themeCache)
  }
  themeCache.set(themeName, result)
}

/**
 * Optimized View component that uses pre-computed theme styles.
 * The compiler generates __styles with resolved values for each theme,
 * eliminating runtime style computation.
 *
 * When native-style-registry is available and native module is loaded:
 * - Component renders ONCE with initial theme style
 * - Theme changes update the view directly via ShadowTree
 * - NO React re-renders on theme change
 *
 * When native module is NOT available (JS fallback):
 * - Uses useThemeName() which subscribes to theme changes
 * - Re-renders on theme change (same as current behavior)
 *
 * Supports deduplicated styles where multiple themes share the same values.
 */
export function _TamaguiView({
  __styles,
  style,
  ...props
}: TamaguiViewProps): React.ReactElement {
  const unlinkRef = useRef<(() => void) | null>(null)

  // check if native module is available ONCE
  const nativeAvailable = registry?.isNativeModuleAvailable?.() ?? false

  // get scope ID from context (if Theme component wrapped us)
  const scopeId = registry?.useThemeScopeId?.()

  // for initial render style:
  // - if native available: use initial theme name (no subscription)
  // - if native NOT available: use useThemeName (subscribes, causes re-renders)
  //
  // the key insight: when native is available, we DON'T subscribe to theme changes
  // because the native registry will update our styles directly via ShadowTree
  //
  const themeName = nativeAvailable
    ? (registry?.useInitialThemeName?.() ?? 'light')
    : useThemeName()

  // ref callback - link/unlink with native registry
  const handleRef = useCallback(
    (instance: View | null) => {
      // cleanup previous link
      if (unlinkRef.current) {
        unlinkRef.current()
        unlinkRef.current = null
      }

      // link new instance (only when native is available)
      if (instance && __styles && registry && nativeAvailable) {
        unlinkRef.current = registry.link(instance, __styles, scopeId)
      }
    },
    [__styles, nativeAvailable, scopeId]
  )

  // cleanup on unmount
  useEffect(() => {
    return () => {
      if (unlinkRef.current) {
        unlinkRef.current()
        unlinkRef.current = null
      }
    }
  }, [])

  // compute style for render
  const themedStyle = __styles ? findStyleForTheme(__styles, themeName) : undefined

  // use View component (not RCTView) because setNativeProps needs the View wrapper
  return (
    <View ref={handleRef} {...props} style={themedStyle ? [themedStyle, style] : style} />
  )
}
