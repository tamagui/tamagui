import type React from 'react'
import { useRef, useEffect, useCallback } from 'react'
import { useThemeName } from '@tamagui/core'
import { View, type ViewProps, type ViewStyle } from 'react-native'

// conditional import for native-style-registry
let registry: typeof import('@tamagui/native-style-registry') | undefined
try {
  registry = require('@tamagui/native-style-registry')
} catch {
  // package not installed, use JS-only mode
}

interface DeduplicatedStyle extends ViewStyle {
  // array of theme names that share this style (for deduplication)
  __themes?: string[]
}

export interface TamaguiViewProps extends ViewProps {
  /**
   * Pre-computed styles for each theme, keyed by theme name.
   * Generated by the compiler at build time.
   * Styles may be deduplicated with __themes array listing all theme names
   * that share the same style.
   */
  __styles?: Record<string, DeduplicatedStyle>
}

// cache for theme -> style lookup to avoid repeated __themes searches
const styleCache = new WeakMap<
  Record<string, DeduplicatedStyle>,
  Map<string, ViewStyle | undefined>
>()

/**
 * Find the style for a theme name from deduplicated __styles.
 * Styles can be keyed directly by theme name OR found via __themes array.
 */
function findStyleForTheme(
  styles: Record<string, DeduplicatedStyle>,
  themeName: string
): ViewStyle | undefined {
  // check cache first
  let themeCache = styleCache.get(styles)
  if (themeCache?.has(themeName)) {
    return themeCache.get(themeName)
  }

  // direct lookup
  if (styles[themeName]) {
    const style = styles[themeName]
    // return style without __themes metadata
    const { __themes, ...cleanStyle } = style
    cacheResult(styles, themeName, cleanStyle)
    return cleanStyle
  }

  // search through __themes arrays
  for (const [key, style] of Object.entries(styles)) {
    if (style.__themes?.includes(themeName)) {
      const { __themes, ...cleanStyle } = style
      cacheResult(styles, themeName, cleanStyle)
      return cleanStyle
    }
  }

  // theme not found, try fallback to base theme (e.g., "dark_blue" -> "dark")
  const baseParts = themeName.split('_')
  if (baseParts.length > 1) {
    const baseTheme = baseParts[0]
    return findStyleForTheme(styles, baseTheme)
  }

  cacheResult(styles, themeName, undefined)
  return undefined
}

function cacheResult(
  styles: Record<string, DeduplicatedStyle>,
  themeName: string,
  result: ViewStyle | undefined
) {
  let themeCache = styleCache.get(styles)
  if (!themeCache) {
    themeCache = new Map()
    styleCache.set(styles, themeCache)
  }
  themeCache.set(themeName, result)
}

/**
 * Optimized View component that uses pre-computed theme styles.
 * The compiler generates __styles with resolved values for each theme,
 * eliminating runtime style computation.
 *
 * When native-style-registry is available and native module is loaded,
 * theme changes update the view directly via ShadowTree without React re-renders.
 *
 * Supports deduplicated styles where multiple themes share the same values.
 */
export function _TamaguiView({
  __styles,
  style,
  ...props
}: TamaguiViewProps): React.ReactElement {
  const unlinkRef = useRef<(() => void) | null>(null)
  const themeName = useThemeName()

  // check if native module is available
  const nativeAvailable = registry?.isNativeModuleAvailable?.() ?? false

  // ref callback - link/unlink with native registry
  const handleRef = useCallback(
    (instance: View | null) => {
      // cleanup previous link
      if (unlinkRef.current) {
        unlinkRef.current()
        unlinkRef.current = null
      }

      // link new instance
      if (instance && __styles && registry && nativeAvailable) {
        unlinkRef.current = registry.link(instance, __styles)
      }
    },
    [__styles, nativeAvailable]
  )

  // cleanup on unmount
  useEffect(() => {
    return () => {
      if (unlinkRef.current) {
        unlinkRef.current()
        unlinkRef.current = null
      }
    }
  }, [])

  // compute initial style for first render (and JS fallback mode)
  const themedStyle = __styles ? findStyleForTheme(__styles, themeName) : undefined

  return (
    <View ref={handleRef} {...props} style={themedStyle ? [themedStyle, style] : style} />
  )
}
