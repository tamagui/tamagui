diff --git a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.mts b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.mts
index d7a3be8..e4c84a6 100644
--- a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.mts
+++ b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.mts
@@ -1,5 +1,6 @@
 import { AlignedPlacement } from '@floating-ui/dom';
 import { Alignment } from '@floating-ui/dom';
+import { autoPlacement } from '@floating-ui/dom';
 import { AutoPlacementOptions } from '@floating-ui/dom';
 import { autoUpdate } from '@floating-ui/dom';
 import { AutoUpdateOptions } from '@floating-ui/dom';
@@ -10,38 +11,44 @@ import { computePosition } from '@floating-ui/dom';
 import { ComputePositionConfig } from '@floating-ui/dom';
 import { ComputePositionReturn } from '@floating-ui/dom';
 import { Coords } from '@floating-ui/dom';
-import { Derivable } from '@floating-ui/dom';
+import type { Derivable } from '@floating-ui/dom';
 import { detectOverflow } from '@floating-ui/dom';
 import { DetectOverflowOptions } from '@floating-ui/dom';
 import { Dimensions } from '@floating-ui/dom';
 import { ElementContext } from '@floating-ui/dom';
 import { ElementRects } from '@floating-ui/dom';
 import { Elements } from '@floating-ui/dom';
+import { flip } from '@floating-ui/dom';
 import { FlipOptions } from '@floating-ui/dom';
 import { FloatingElement } from '@floating-ui/dom';
 import { getOverflowAncestors } from '@floating-ui/dom';
+import { hide } from '@floating-ui/dom';
 import { HideOptions } from '@floating-ui/dom';
+import { inline } from '@floating-ui/dom';
 import { InlineOptions } from '@floating-ui/dom';
 import { Length } from '@floating-ui/dom';
-import { limitShift as limitShift_2 } from '@floating-ui/dom';
+import { limitShift } from '@floating-ui/dom';
 import { Middleware } from '@floating-ui/dom';
 import { MiddlewareArguments } from '@floating-ui/dom';
 import { MiddlewareData } from '@floating-ui/dom';
 import { MiddlewareReturn } from '@floating-ui/dom';
 import { MiddlewareState } from '@floating-ui/dom';
 import { NodeScroll } from '@floating-ui/dom';
+import { offset } from '@floating-ui/dom';
 import { OffsetOptions } from '@floating-ui/dom';
 import { Padding } from '@floating-ui/dom';
 import { Placement } from '@floating-ui/dom';
 import { Platform } from '@floating-ui/dom';
 import { platform } from '@floating-ui/dom';
-import type * as React from 'react';
+import type * as React_2 from 'react';
 import { Rect } from '@floating-ui/dom';
 import { ReferenceElement } from '@floating-ui/dom';
 import { RootBoundary } from '@floating-ui/dom';
+import { shift } from '@floating-ui/dom';
 import { ShiftOptions } from '@floating-ui/dom';
 import { Side } from '@floating-ui/dom';
 import { SideObject } from '@floating-ui/dom';
+import { size } from '@floating-ui/dom';
 import { SizeOptions } from '@floating-ui/dom';
 import { Strategy } from '@floating-ui/dom';
 import { VirtualElement } from '@floating-ui/dom';
@@ -56,14 +63,14 @@ export { Alignment }
  * This wraps the core `arrow` middleware to allow React refs as the element.
  * @see https://floating-ui.com/docs/arrow
  */
-export declare const arrow: (options: ArrowOptions | Derivable<ArrowOptions>, deps?: React.DependencyList) => Middleware;
+export declare const arrow: (options: ArrowOptions | Derivable<ArrowOptions>) => Middleware;
 
 export declare interface ArrowOptions {
     /**
      * The arrow element to be positioned.
      * @default undefined
      */
-    element: React.MutableRefObject<Element | null> | Element | null;
+    element: React_2.MutableRefObject<Element | null> | Element | null;
     /**
      * The padding between the arrow element and the floating element edges.
      * Useful when the floating element has rounded corners.
@@ -72,13 +79,7 @@ export declare interface ArrowOptions {
     padding?: Padding;
 }
 
-/**
- * Optimizes the visibility of the floating element by choosing the placement
- * that has the most space available automatically, without needing to specify a
- * preferred placement. Alternative to `flip`.
- * @see https://floating-ui.com/docs/autoPlacement
- */
-export declare const autoPlacement: (options?: AutoPlacementOptions | Derivable<AutoPlacementOptions>, deps?: React.DependencyList) => Middleware;
+export { autoPlacement }
 
 export { AutoPlacementOptions }
 
@@ -112,13 +113,7 @@ export { ElementRects }
 
 export { Elements }
 
-/**
- * Optimizes the visibility of the floating element by flipping the `placement`
- * in order to keep it in view when the preferred placement(s) will overflow the
- * clipping boundary. Alternative to `autoPlacement`.
- * @see https://floating-ui.com/docs/flip
- */
-export declare const flip: (options?: FlipOptions | Derivable<FlipOptions>, deps?: React.DependencyList) => Middleware;
+export { flip }
 
 export { FlipOptions }
 
@@ -126,35 +121,17 @@ export { FloatingElement }
 
 export { getOverflowAncestors }
 
-/**
- * Provides data to hide the floating element in applicable situations, such as
- * when it is not in the same clipping context as the reference element.
- * @see https://floating-ui.com/docs/hide
- */
-export declare const hide: (options?: HideOptions | Derivable<HideOptions>, deps?: React.DependencyList) => Middleware;
+export { hide }
 
 export { HideOptions }
 
-/**
- * Provides improved positioning for inline reference elements that can span
- * over multiple lines, such as hyperlinks or range selections.
- * @see https://floating-ui.com/docs/inline
- */
-export declare const inline: (options?: InlineOptions | Derivable<InlineOptions>, deps?: React.DependencyList) => Middleware;
+export { inline }
 
 export { InlineOptions }
 
 export { Length }
 
-/**
- * Built-in `limiter` that will stop `shift()` at a certain point.
- */
-export declare const limitShift: (options?: LimitShiftOptions, deps?: React.DependencyList) => {
-    fn: (state: MiddlewareState) => Coords;
-    options: any;
-};
-
-declare type LimitShiftOptions = Parameters<typeof limitShift_2>[0];
+export { limitShift }
 
 export { Middleware }
 
@@ -168,14 +145,7 @@ export { MiddlewareState }
 
 export { NodeScroll }
 
-/**
- * Modifies the placement by translating the floating element along the
- * specified axes.
- * A number (shorthand for `mainAxis` or distance), or an axes configuration
- * object may be passed.
- * @see https://floating-ui.com/docs/offset
- */
-export declare const offset: (options?: OffsetOptions, deps?: React.DependencyList) => Middleware;
+export { offset }
 
 export { OffsetOptions }
 
@@ -199,12 +169,7 @@ export declare type ReferenceType = Element | VirtualElement;
 
 export { RootBoundary }
 
-/**
- * Optimizes the visibility of the floating element by shifting it in order to
- * keep it in view when it will overflow the clipping boundary.
- * @see https://floating-ui.com/docs/shift
- */
-export declare const shift: (options?: ShiftOptions | Derivable<ShiftOptions>, deps?: React.DependencyList) => Middleware;
+export { shift }
 
 export { ShiftOptions }
 
@@ -212,13 +177,7 @@ export { Side }
 
 export { SideObject }
 
-/**
- * Provides data that allows you to change the size of the floating element —
- * for instance, prevent it from overflowing the clipping boundary or match the
- * width of the reference element.
- * @see https://floating-ui.com/docs/size
- */
-export declare const size: (options?: SizeOptions | Derivable<SizeOptions>, deps?: React.DependencyList) => Middleware;
+export { size }
 
 export { SizeOptions }
 
@@ -266,7 +225,7 @@ export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType>
     /**
      * Pre-configured positioning styles to apply to the floating element.
      */
-    floatingStyles: React.CSSProperties;
+    floatingStyles: React_2.CSSProperties;
     /**
      * Object containing the reference and floating refs and reactive setters.
      */
@@ -274,11 +233,11 @@ export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType>
         /**
          * A React ref to the reference element.
          */
-        reference: React.MutableRefObject<RT | null>;
+        reference: React_2.MutableRefObject<RT | null>;
         /**
          * A React ref to the floating element.
          */
-        floating: React.MutableRefObject<HTMLElement | null>;
+        floating: React_2.MutableRefObject<HTMLElement | null>;
         /**
          * A callback to set the reference element (reactive).
          */
diff --git a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.ts b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.ts
index d7a3be8..e4c84a6 100644
--- a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.ts
+++ b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.d.ts
@@ -1,5 +1,6 @@
 import { AlignedPlacement } from '@floating-ui/dom';
 import { Alignment } from '@floating-ui/dom';
+import { autoPlacement } from '@floating-ui/dom';
 import { AutoPlacementOptions } from '@floating-ui/dom';
 import { autoUpdate } from '@floating-ui/dom';
 import { AutoUpdateOptions } from '@floating-ui/dom';
@@ -10,38 +11,44 @@ import { computePosition } from '@floating-ui/dom';
 import { ComputePositionConfig } from '@floating-ui/dom';
 import { ComputePositionReturn } from '@floating-ui/dom';
 import { Coords } from '@floating-ui/dom';
-import { Derivable } from '@floating-ui/dom';
+import type { Derivable } from '@floating-ui/dom';
 import { detectOverflow } from '@floating-ui/dom';
 import { DetectOverflowOptions } from '@floating-ui/dom';
 import { Dimensions } from '@floating-ui/dom';
 import { ElementContext } from '@floating-ui/dom';
 import { ElementRects } from '@floating-ui/dom';
 import { Elements } from '@floating-ui/dom';
+import { flip } from '@floating-ui/dom';
 import { FlipOptions } from '@floating-ui/dom';
 import { FloatingElement } from '@floating-ui/dom';
 import { getOverflowAncestors } from '@floating-ui/dom';
+import { hide } from '@floating-ui/dom';
 import { HideOptions } from '@floating-ui/dom';
+import { inline } from '@floating-ui/dom';
 import { InlineOptions } from '@floating-ui/dom';
 import { Length } from '@floating-ui/dom';
-import { limitShift as limitShift_2 } from '@floating-ui/dom';
+import { limitShift } from '@floating-ui/dom';
 import { Middleware } from '@floating-ui/dom';
 import { MiddlewareArguments } from '@floating-ui/dom';
 import { MiddlewareData } from '@floating-ui/dom';
 import { MiddlewareReturn } from '@floating-ui/dom';
 import { MiddlewareState } from '@floating-ui/dom';
 import { NodeScroll } from '@floating-ui/dom';
+import { offset } from '@floating-ui/dom';
 import { OffsetOptions } from '@floating-ui/dom';
 import { Padding } from '@floating-ui/dom';
 import { Placement } from '@floating-ui/dom';
 import { Platform } from '@floating-ui/dom';
 import { platform } from '@floating-ui/dom';
-import type * as React from 'react';
+import type * as React_2 from 'react';
 import { Rect } from '@floating-ui/dom';
 import { ReferenceElement } from '@floating-ui/dom';
 import { RootBoundary } from '@floating-ui/dom';
+import { shift } from '@floating-ui/dom';
 import { ShiftOptions } from '@floating-ui/dom';
 import { Side } from '@floating-ui/dom';
 import { SideObject } from '@floating-ui/dom';
+import { size } from '@floating-ui/dom';
 import { SizeOptions } from '@floating-ui/dom';
 import { Strategy } from '@floating-ui/dom';
 import { VirtualElement } from '@floating-ui/dom';
@@ -56,14 +63,14 @@ export { Alignment }
  * This wraps the core `arrow` middleware to allow React refs as the element.
  * @see https://floating-ui.com/docs/arrow
  */
-export declare const arrow: (options: ArrowOptions | Derivable<ArrowOptions>, deps?: React.DependencyList) => Middleware;
+export declare const arrow: (options: ArrowOptions | Derivable<ArrowOptions>) => Middleware;
 
 export declare interface ArrowOptions {
     /**
      * The arrow element to be positioned.
      * @default undefined
      */
-    element: React.MutableRefObject<Element | null> | Element | null;
+    element: React_2.MutableRefObject<Element | null> | Element | null;
     /**
      * The padding between the arrow element and the floating element edges.
      * Useful when the floating element has rounded corners.
@@ -72,13 +79,7 @@ export declare interface ArrowOptions {
     padding?: Padding;
 }
 
-/**
- * Optimizes the visibility of the floating element by choosing the placement
- * that has the most space available automatically, without needing to specify a
- * preferred placement. Alternative to `flip`.
- * @see https://floating-ui.com/docs/autoPlacement
- */
-export declare const autoPlacement: (options?: AutoPlacementOptions | Derivable<AutoPlacementOptions>, deps?: React.DependencyList) => Middleware;
+export { autoPlacement }
 
 export { AutoPlacementOptions }
 
@@ -112,13 +113,7 @@ export { ElementRects }
 
 export { Elements }
 
-/**
- * Optimizes the visibility of the floating element by flipping the `placement`
- * in order to keep it in view when the preferred placement(s) will overflow the
- * clipping boundary. Alternative to `autoPlacement`.
- * @see https://floating-ui.com/docs/flip
- */
-export declare const flip: (options?: FlipOptions | Derivable<FlipOptions>, deps?: React.DependencyList) => Middleware;
+export { flip }
 
 export { FlipOptions }
 
@@ -126,35 +121,17 @@ export { FloatingElement }
 
 export { getOverflowAncestors }
 
-/**
- * Provides data to hide the floating element in applicable situations, such as
- * when it is not in the same clipping context as the reference element.
- * @see https://floating-ui.com/docs/hide
- */
-export declare const hide: (options?: HideOptions | Derivable<HideOptions>, deps?: React.DependencyList) => Middleware;
+export { hide }
 
 export { HideOptions }
 
-/**
- * Provides improved positioning for inline reference elements that can span
- * over multiple lines, such as hyperlinks or range selections.
- * @see https://floating-ui.com/docs/inline
- */
-export declare const inline: (options?: InlineOptions | Derivable<InlineOptions>, deps?: React.DependencyList) => Middleware;
+export { inline }
 
 export { InlineOptions }
 
 export { Length }
 
-/**
- * Built-in `limiter` that will stop `shift()` at a certain point.
- */
-export declare const limitShift: (options?: LimitShiftOptions, deps?: React.DependencyList) => {
-    fn: (state: MiddlewareState) => Coords;
-    options: any;
-};
-
-declare type LimitShiftOptions = Parameters<typeof limitShift_2>[0];
+export { limitShift }
 
 export { Middleware }
 
@@ -168,14 +145,7 @@ export { MiddlewareState }
 
 export { NodeScroll }
 
-/**
- * Modifies the placement by translating the floating element along the
- * specified axes.
- * A number (shorthand for `mainAxis` or distance), or an axes configuration
- * object may be passed.
- * @see https://floating-ui.com/docs/offset
- */
-export declare const offset: (options?: OffsetOptions, deps?: React.DependencyList) => Middleware;
+export { offset }
 
 export { OffsetOptions }
 
@@ -199,12 +169,7 @@ export declare type ReferenceType = Element | VirtualElement;
 
 export { RootBoundary }
 
-/**
- * Optimizes the visibility of the floating element by shifting it in order to
- * keep it in view when it will overflow the clipping boundary.
- * @see https://floating-ui.com/docs/shift
- */
-export declare const shift: (options?: ShiftOptions | Derivable<ShiftOptions>, deps?: React.DependencyList) => Middleware;
+export { shift }
 
 export { ShiftOptions }
 
@@ -212,13 +177,7 @@ export { Side }
 
 export { SideObject }
 
-/**
- * Provides data that allows you to change the size of the floating element —
- * for instance, prevent it from overflowing the clipping boundary or match the
- * width of the reference element.
- * @see https://floating-ui.com/docs/size
- */
-export declare const size: (options?: SizeOptions | Derivable<SizeOptions>, deps?: React.DependencyList) => Middleware;
+export { size }
 
 export { SizeOptions }
 
@@ -266,7 +225,7 @@ export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType>
     /**
      * Pre-configured positioning styles to apply to the floating element.
      */
-    floatingStyles: React.CSSProperties;
+    floatingStyles: React_2.CSSProperties;
     /**
      * Object containing the reference and floating refs and reactive setters.
      */
@@ -274,11 +233,11 @@ export declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType>
         /**
          * A React ref to the reference element.
          */
-        reference: React.MutableRefObject<RT | null>;
+        reference: React_2.MutableRefObject<RT | null>;
         /**
          * A React ref to the floating element.
          */
-        floating: React.MutableRefObject<HTMLElement | null>;
+        floating: React_2.MutableRefObject<HTMLElement | null>;
         /**
          * A callback to set the reference element (reactive).
          */
diff --git a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
index f699f76..5acc03d 100644
--- a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
+++ b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
@@ -1,9 +1,47 @@
-import { computePosition, arrow as arrow$2, offset as offset$1, shift as shift$1, limitShift as limitShift$1, flip as flip$1, size as size$1, autoPlacement as autoPlacement$1, hide as hide$1, inline as inline$1 } from '@floating-ui/dom';
-export { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';
+import { arrow as arrow$1, computePosition } from '@floating-ui/dom';
+export { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';
 import * as React from 'react';
 import { useLayoutEffect, useEffect } from 'react';
 import * as ReactDOM from 'react-dom';
 
+/**
+ * Provides data to position an inner element of the floating element so that it
+ * appears centered to the reference element.
+ * This wraps the core `arrow` middleware to allow React refs as the element.
+ * @see https://floating-ui.com/docs/arrow
+ */
+const arrow = options => {
+  function isRef(value) {
+    return {}.hasOwnProperty.call(value, 'current');
+  }
+  return {
+    name: 'arrow',
+    options,
+    fn(state) {
+      const {
+        element,
+        padding
+      } = typeof options === 'function' ? options(state) : options;
+      if (element && isRef(element)) {
+        if (element.current != null) {
+          return arrow$1({
+            element: element.current,
+            padding
+          }).fn(state);
+        }
+        return {};
+      }
+      if (element) {
+        return arrow$1({
+          element,
+          padding
+        }).fn(state);
+      }
+      return {};
+    }
+  };
+};
+
 var index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;
 
 // Fork of `fast-deep-equal` that only does the comparisons we need and compares
@@ -53,6 +91,8 @@ function deepEqual(a, b) {
     }
     return true;
   }
+
+  // biome-ignore lint/suspicious/noSelfCompare: in source
   return a !== a && b !== b;
 }
 
@@ -173,6 +213,8 @@ function useFloating(options) {
       isMountedRef.current = false;
     };
   }, []);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.
   index(() => {
     if (referenceEl) referenceRef.current = referenceEl;
     if (floatingEl) floatingRef.current = floatingEl;
@@ -228,135 +270,4 @@ function useFloating(options) {
   }), [data, update, refs, elements, floatingStyles]);
 }
 
-/**
- * Provides data to position an inner element of the floating element so that it
- * appears centered to the reference element.
- * This wraps the core `arrow` middleware to allow React refs as the element.
- * @see https://floating-ui.com/docs/arrow
- */
-const arrow$1 = options => {
-  function isRef(value) {
-    return {}.hasOwnProperty.call(value, 'current');
-  }
-  return {
-    name: 'arrow',
-    options,
-    fn(state) {
-      const {
-        element,
-        padding
-      } = typeof options === 'function' ? options(state) : options;
-      if (element && isRef(element)) {
-        if (element.current != null) {
-          return arrow$2({
-            element: element.current,
-            padding
-          }).fn(state);
-        }
-        return {};
-      }
-      if (element) {
-        return arrow$2({
-          element,
-          padding
-        }).fn(state);
-      }
-      return {};
-    }
-  };
-};
-
-/**
- * Modifies the placement by translating the floating element along the
- * specified axes.
- * A number (shorthand for `mainAxis` or distance), or an axes configuration
- * object may be passed.
- * @see https://floating-ui.com/docs/offset
- */
-const offset = (options, deps) => ({
-  ...offset$1(options),
-  options: [options, deps]
-});
-
-/**
- * Optimizes the visibility of the floating element by shifting it in order to
- * keep it in view when it will overflow the clipping boundary.
- * @see https://floating-ui.com/docs/shift
- */
-const shift = (options, deps) => ({
-  ...shift$1(options),
-  options: [options, deps]
-});
-/**
- * Built-in `limiter` that will stop `shift()` at a certain point.
- */
-const limitShift = (options, deps) => ({
-  ...limitShift$1(options),
-  options: [options, deps]
-});
-
-/**
- * Optimizes the visibility of the floating element by flipping the `placement`
- * in order to keep it in view when the preferred placement(s) will overflow the
- * clipping boundary. Alternative to `autoPlacement`.
- * @see https://floating-ui.com/docs/flip
- */
-const flip = (options, deps) => ({
-  ...flip$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides data that allows you to change the size of the floating element —
- * for instance, prevent it from overflowing the clipping boundary or match the
- * width of the reference element.
- * @see https://floating-ui.com/docs/size
- */
-const size = (options, deps) => ({
-  ...size$1(options),
-  options: [options, deps]
-});
-
-/**
- * Optimizes the visibility of the floating element by choosing the placement
- * that has the most space available automatically, without needing to specify a
- * preferred placement. Alternative to `flip`.
- * @see https://floating-ui.com/docs/autoPlacement
- */
-const autoPlacement = (options, deps) => ({
-  ...autoPlacement$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides data to hide the floating element in applicable situations, such as
- * when it is not in the same clipping context as the reference element.
- * @see https://floating-ui.com/docs/hide
- */
-const hide = (options, deps) => ({
-  ...hide$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides improved positioning for inline reference elements that can span
- * over multiple lines, such as hyperlinks or range selections.
- * @see https://floating-ui.com/docs/inline
- */
-const inline = (options, deps) => ({
-  ...inline$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides data to position an inner element of the floating element so that it
- * appears centered to the reference element.
- * This wraps the core `arrow` middleware to allow React refs as the element.
- * @see https://floating-ui.com/docs/arrow
- */
-const arrow = (options, deps) => ({
-  ...arrow$1(options),
-  options: [options, deps]
-});
-
-export { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };
+export { arrow, useFloating };
diff --git a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
index f699f76..4b336ba 100644
--- a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
+++ b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
@@ -1,9 +1,62 @@
-import { computePosition, arrow as arrow$2, offset as offset$1, shift as shift$1, limitShift as limitShift$1, flip as flip$1, size as size$1, autoPlacement as autoPlacement$1, hide as hide$1, inline as inline$1 } from '@floating-ui/dom';
-export { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';
+import { arrow as arrow$1, computePosition } from '@floating-ui/dom';
+export { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';
 import * as React from 'react';
 import { useLayoutEffect, useEffect } from 'react';
 import * as ReactDOM from 'react-dom';
 
+export const useTransitionState = ((val) => {
+  const [a, b] = useState(val)
+  // @ts-ignore
+  const wrapped = useCallback(
+    (...args) => {
+      startTransition(() => {
+        // @ts-ignore
+        b(...args)
+      })
+    },
+    [b]
+  )
+  return [a, wrapped]
+})
+
+/**
+ * Provides data to position an inner element of the floating element so that it
+ * appears centered to the reference element.
+ * This wraps the core `arrow` middleware to allow React refs as the element.
+ * @see https://floating-ui.com/docs/arrow
+ */
+const arrow = options => {
+  function isRef(value) {
+    return {}.hasOwnProperty.call(value, 'current');
+  }
+  return {
+    name: 'arrow',
+    options,
+    fn(state) {
+      const {
+        element,
+        padding
+      } = typeof options === 'function' ? options(state) : options;
+      if (element && isRef(element)) {
+        if (element.current != null) {
+          return arrow$1({
+            element: element.current,
+            padding
+          }).fn(state);
+        }
+        return {};
+      }
+      if (element) {
+        return arrow$1({
+          element,
+          padding
+        }).fn(state);
+      }
+      return {};
+    }
+  };
+};
+
 var index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;
 
 // Fork of `fast-deep-equal` that only does the comparisons we need and compares
@@ -53,6 +106,8 @@ function deepEqual(a, b) {
     }
     return true;
   }
+
+  // biome-ignore lint/suspicious/noSelfCompare: in source
   return a !== a && b !== b;
 }
 
@@ -98,7 +153,7 @@ function useFloating(options) {
     whileElementsMounted,
     open
   } = options;
-  const [data, setData] = React.useState({
+  const [data, setData] = useTransitionState({
     x: 0,
     y: 0,
     strategy,
@@ -106,12 +161,12 @@ function useFloating(options) {
     middlewareData: {},
     isPositioned: false
   });
-  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
+  const [latestMiddleware, setLatestMiddleware] = useTransitionState(middleware);
   if (!deepEqual(latestMiddleware, middleware)) {
     setLatestMiddleware(middleware);
   }
-  const [_reference, _setReference] = React.useState(null);
-  const [_floating, _setFloating] = React.useState(null);
+  const [_reference, _setReference] = useTransitionState(null);
+  const [_floating, _setFloating] = useTransitionState(null);
   const setReference = React.useCallback(node => {
     if (node !== referenceRef.current) {
       referenceRef.current = node;
@@ -173,6 +228,8 @@ function useFloating(options) {
       isMountedRef.current = false;
     };
   }, []);
+
+  // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.
   index(() => {
     if (referenceEl) referenceRef.current = referenceEl;
     if (floatingEl) floatingRef.current = floatingEl;
@@ -228,135 +285,4 @@ function useFloating(options) {
   }), [data, update, refs, elements, floatingStyles]);
 }
 
-/**
- * Provides data to position an inner element of the floating element so that it
- * appears centered to the reference element.
- * This wraps the core `arrow` middleware to allow React refs as the element.
- * @see https://floating-ui.com/docs/arrow
- */
-const arrow$1 = options => {
-  function isRef(value) {
-    return {}.hasOwnProperty.call(value, 'current');
-  }
-  return {
-    name: 'arrow',
-    options,
-    fn(state) {
-      const {
-        element,
-        padding
-      } = typeof options === 'function' ? options(state) : options;
-      if (element && isRef(element)) {
-        if (element.current != null) {
-          return arrow$2({
-            element: element.current,
-            padding
-          }).fn(state);
-        }
-        return {};
-      }
-      if (element) {
-        return arrow$2({
-          element,
-          padding
-        }).fn(state);
-      }
-      return {};
-    }
-  };
-};
-
-/**
- * Modifies the placement by translating the floating element along the
- * specified axes.
- * A number (shorthand for `mainAxis` or distance), or an axes configuration
- * object may be passed.
- * @see https://floating-ui.com/docs/offset
- */
-const offset = (options, deps) => ({
-  ...offset$1(options),
-  options: [options, deps]
-});
-
-/**
- * Optimizes the visibility of the floating element by shifting it in order to
- * keep it in view when it will overflow the clipping boundary.
- * @see https://floating-ui.com/docs/shift
- */
-const shift = (options, deps) => ({
-  ...shift$1(options),
-  options: [options, deps]
-});
-/**
- * Built-in `limiter` that will stop `shift()` at a certain point.
- */
-const limitShift = (options, deps) => ({
-  ...limitShift$1(options),
-  options: [options, deps]
-});
-
-/**
- * Optimizes the visibility of the floating element by flipping the `placement`
- * in order to keep it in view when the preferred placement(s) will overflow the
- * clipping boundary. Alternative to `autoPlacement`.
- * @see https://floating-ui.com/docs/flip
- */
-const flip = (options, deps) => ({
-  ...flip$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides data that allows you to change the size of the floating element —
- * for instance, prevent it from overflowing the clipping boundary or match the
- * width of the reference element.
- * @see https://floating-ui.com/docs/size
- */
-const size = (options, deps) => ({
-  ...size$1(options),
-  options: [options, deps]
-});
-
-/**
- * Optimizes the visibility of the floating element by choosing the placement
- * that has the most space available automatically, without needing to specify a
- * preferred placement. Alternative to `flip`.
- * @see https://floating-ui.com/docs/autoPlacement
- */
-const autoPlacement = (options, deps) => ({
-  ...autoPlacement$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides data to hide the floating element in applicable situations, such as
- * when it is not in the same clipping context as the reference element.
- * @see https://floating-ui.com/docs/hide
- */
-const hide = (options, deps) => ({
-  ...hide$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides improved positioning for inline reference elements that can span
- * over multiple lines, such as hyperlinks or range selections.
- * @see https://floating-ui.com/docs/inline
- */
-const inline = (options, deps) => ({
-  ...inline$1(options),
-  options: [options, deps]
-});
-
-/**
- * Provides data to position an inner element of the floating element so that it
- * appears centered to the reference element.
- * This wraps the core `arrow` middleware to allow React refs as the element.
- * @see https://floating-ui.com/docs/arrow
- */
-const arrow = (options, deps) => ({
-  ...arrow$1(options),
-  options: [options, deps]
-});
-
-export { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };
+export { arrow, useFloating };
diff --git a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.js b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.js
index 62af9f6..125ce49 100644
--- a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.js
+++ b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.js
@@ -24,6 +24,44 @@
   var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
   var ReactDOM__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM);
 
+  /**
+   * Provides data to position an inner element of the floating element so that it
+   * appears centered to the reference element.
+   * This wraps the core `arrow` middleware to allow React refs as the element.
+   * @see https://floating-ui.com/docs/arrow
+   */
+  const arrow = options => {
+    function isRef(value) {
+      return {}.hasOwnProperty.call(value, 'current');
+    }
+    return {
+      name: 'arrow',
+      options,
+      fn(state) {
+        const {
+          element,
+          padding
+        } = typeof options === 'function' ? options(state) : options;
+        if (element && isRef(element)) {
+          if (element.current != null) {
+            return dom.arrow({
+              element: element.current,
+              padding
+            }).fn(state);
+          }
+          return {};
+        }
+        if (element) {
+          return dom.arrow({
+            element,
+            padding
+          }).fn(state);
+        }
+        return {};
+      }
+    };
+  };
+
   var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;
 
   // Fork of `fast-deep-equal` that only does the comparisons we need and compares
@@ -73,6 +111,8 @@
       }
       return true;
     }
+
+    // biome-ignore lint/suspicious/noSelfCompare: in source
     return a !== a && b !== b;
   }
 
@@ -193,6 +233,8 @@
         isMountedRef.current = false;
       };
     }, []);
+
+    // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.
     index(() => {
       if (referenceEl) referenceRef.current = referenceEl;
       if (floatingEl) floatingRef.current = floatingEl;
@@ -248,137 +290,10 @@
     }), [data, update, refs, elements, floatingStyles]);
   }
 
-  /**
-   * Provides data to position an inner element of the floating element so that it
-   * appears centered to the reference element.
-   * This wraps the core `arrow` middleware to allow React refs as the element.
-   * @see https://floating-ui.com/docs/arrow
-   */
-  const arrow$1 = options => {
-    function isRef(value) {
-      return {}.hasOwnProperty.call(value, 'current');
-    }
-    return {
-      name: 'arrow',
-      options,
-      fn(state) {
-        const {
-          element,
-          padding
-        } = typeof options === 'function' ? options(state) : options;
-        if (element && isRef(element)) {
-          if (element.current != null) {
-            return dom.arrow({
-              element: element.current,
-              padding
-            }).fn(state);
-          }
-          return {};
-        }
-        if (element) {
-          return dom.arrow({
-            element,
-            padding
-          }).fn(state);
-        }
-        return {};
-      }
-    };
-  };
-
-  /**
-   * Modifies the placement by translating the floating element along the
-   * specified axes.
-   * A number (shorthand for `mainAxis` or distance), or an axes configuration
-   * object may be passed.
-   * @see https://floating-ui.com/docs/offset
-   */
-  const offset = (options, deps) => ({
-    ...dom.offset(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Optimizes the visibility of the floating element by shifting it in order to
-   * keep it in view when it will overflow the clipping boundary.
-   * @see https://floating-ui.com/docs/shift
-   */
-  const shift = (options, deps) => ({
-    ...dom.shift(options),
-    options: [options, deps]
-  });
-  /**
-   * Built-in `limiter` that will stop `shift()` at a certain point.
-   */
-  const limitShift = (options, deps) => ({
-    ...dom.limitShift(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Optimizes the visibility of the floating element by flipping the `placement`
-   * in order to keep it in view when the preferred placement(s) will overflow the
-   * clipping boundary. Alternative to `autoPlacement`.
-   * @see https://floating-ui.com/docs/flip
-   */
-  const flip = (options, deps) => ({
-    ...dom.flip(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Provides data that allows you to change the size of the floating element —
-   * for instance, prevent it from overflowing the clipping boundary or match the
-   * width of the reference element.
-   * @see https://floating-ui.com/docs/size
-   */
-  const size = (options, deps) => ({
-    ...dom.size(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Optimizes the visibility of the floating element by choosing the placement
-   * that has the most space available automatically, without needing to specify a
-   * preferred placement. Alternative to `flip`.
-   * @see https://floating-ui.com/docs/autoPlacement
-   */
-  const autoPlacement = (options, deps) => ({
-    ...dom.autoPlacement(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Provides data to hide the floating element in applicable situations, such as
-   * when it is not in the same clipping context as the reference element.
-   * @see https://floating-ui.com/docs/hide
-   */
-  const hide = (options, deps) => ({
-    ...dom.hide(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Provides improved positioning for inline reference elements that can span
-   * over multiple lines, such as hyperlinks or range selections.
-   * @see https://floating-ui.com/docs/inline
-   */
-  const inline = (options, deps) => ({
-    ...dom.inline(options),
-    options: [options, deps]
-  });
-
-  /**
-   * Provides data to position an inner element of the floating element so that it
-   * appears centered to the reference element.
-   * This wraps the core `arrow` middleware to allow React refs as the element.
-   * @see https://floating-ui.com/docs/arrow
-   */
-  const arrow = (options, deps) => ({
-    ...arrow$1(options),
-    options: [options, deps]
+  Object.defineProperty(exports, "autoPlacement", {
+    enumerable: true,
+    get: function () { return dom.autoPlacement; }
   });
-
   Object.defineProperty(exports, "autoUpdate", {
     enumerable: true,
     get: function () { return dom.autoUpdate; }
@@ -391,23 +306,43 @@
     enumerable: true,
     get: function () { return dom.detectOverflow; }
   });
+  Object.defineProperty(exports, "flip", {
+    enumerable: true,
+    get: function () { return dom.flip; }
+  });
   Object.defineProperty(exports, "getOverflowAncestors", {
     enumerable: true,
     get: function () { return dom.getOverflowAncestors; }
   });
+  Object.defineProperty(exports, "hide", {
+    enumerable: true,
+    get: function () { return dom.hide; }
+  });
+  Object.defineProperty(exports, "inline", {
+    enumerable: true,
+    get: function () { return dom.inline; }
+  });
+  Object.defineProperty(exports, "limitShift", {
+    enumerable: true,
+    get: function () { return dom.limitShift; }
+  });
+  Object.defineProperty(exports, "offset", {
+    enumerable: true,
+    get: function () { return dom.offset; }
+  });
   Object.defineProperty(exports, "platform", {
     enumerable: true,
     get: function () { return dom.platform; }
   });
+  Object.defineProperty(exports, "shift", {
+    enumerable: true,
+    get: function () { return dom.shift; }
+  });
+  Object.defineProperty(exports, "size", {
+    enumerable: true,
+    get: function () { return dom.size; }
+  });
   exports.arrow = arrow;
-  exports.autoPlacement = autoPlacement;
-  exports.flip = flip;
-  exports.hide = hide;
-  exports.inline = inline;
-  exports.limitShift = limitShift;
-  exports.offset = offset;
-  exports.shift = shift;
-  exports.size = size;
   exports.useFloating = useFloating;
 
 }));
diff --git a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.min.js b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.min.js
index f435807..176732b 100644
--- a/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.min.js
+++ b/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.min.js
@@ -1 +1 @@
-!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@floating-ui/dom"),require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["exports","@floating-ui/dom","react","react-dom"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FloatingUIReactDOM={},e.FloatingUIDOM,e.React,e.ReactDOM)}(this,(function(e,t,n,r){"use strict";function o(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var i=o(n),u=o(r),f="undefined"!=typeof document?n.useLayoutEffect:n.useEffect;function c(e,t){if(e===t)return!0;if(typeof e!=typeof t)return!1;if("function"==typeof e&&e.toString()===t.toString())return!0;let n,r,o;if(e&&t&&"object"==typeof e){if(Array.isArray(e)){if(n=e.length,n!==t.length)return!1;for(r=n;0!=r--;)if(!c(e[r],t[r]))return!1;return!0}if(o=Object.keys(e),n=o.length,n!==Object.keys(t).length)return!1;for(r=n;0!=r--;)if(!{}.hasOwnProperty.call(t,o[r]))return!1;for(r=n;0!=r--;){const n=o[r];if(("_owner"!==n||!e.$$typeof)&&!c(e[n],t[n]))return!1}return!0}return e!=e&&t!=t}function s(e){if("undefined"==typeof window)return 1;return(e.ownerDocument.defaultView||window).devicePixelRatio||1}function a(e,t){const n=s(e);return Math.round(t*n)/n}function l(e){const t=i.useRef(e);return f((()=>{t.current=e})),t}const p=e=>({name:"arrow",options:e,fn(n){const{element:r,padding:o}="function"==typeof e?e(n):e;return r&&(i=r,{}.hasOwnProperty.call(i,"current"))?null!=r.current?t.arrow({element:r.current,padding:o}).fn(n):{}:r?t.arrow({element:r,padding:o}).fn(n):{};var i}});Object.defineProperty(e,"autoUpdate",{enumerable:!0,get:function(){return t.autoUpdate}}),Object.defineProperty(e,"computePosition",{enumerable:!0,get:function(){return t.computePosition}}),Object.defineProperty(e,"detectOverflow",{enumerable:!0,get:function(){return t.detectOverflow}}),Object.defineProperty(e,"getOverflowAncestors",{enumerable:!0,get:function(){return t.getOverflowAncestors}}),Object.defineProperty(e,"platform",{enumerable:!0,get:function(){return t.platform}}),e.arrow=(e,t)=>({...p(e),options:[e,t]}),e.autoPlacement=(e,n)=>({...t.autoPlacement(e),options:[e,n]}),e.flip=(e,n)=>({...t.flip(e),options:[e,n]}),e.hide=(e,n)=>({...t.hide(e),options:[e,n]}),e.inline=(e,n)=>({...t.inline(e),options:[e,n]}),e.limitShift=(e,n)=>({...t.limitShift(e),options:[e,n]}),e.offset=(e,n)=>({...t.offset(e),options:[e,n]}),e.shift=(e,n)=>({...t.shift(e),options:[e,n]}),e.size=(e,n)=>({...t.size(e),options:[e,n]}),e.useFloating=function(e){void 0===e&&(e={});const{placement:n="bottom",strategy:r="absolute",middleware:o=[],platform:p,elements:{reference:d,floating:m}={},transform:g=!0,whileElementsMounted:y,open:b}=e,[w,O]=i.useState({x:0,y:0,strategy:r,placement:n,middlewareData:{},isPositioned:!1}),[h,P]=i.useState(o);c(h,o)||P(o);const[j,v]=i.useState(null),[R,S]=i.useState(null),x=i.useCallback((e=>{e!==A.current&&(A.current=e,v(e))}),[]),M=i.useCallback((e=>{e!==C.current&&(C.current=e,S(e))}),[]),k=d||j,D=m||R,A=i.useRef(null),C=i.useRef(null),E=i.useRef(w),F=null!=y,U=l(y),q=l(p),z=i.useCallback((()=>{if(!A.current||!C.current)return;const e={placement:n,strategy:r,middleware:h};q.current&&(e.platform=q.current),t.computePosition(A.current,C.current,e).then((e=>{const t={...e,isPositioned:!0};I.current&&!c(E.current,t)&&(E.current=t,u.flushSync((()=>{O(t)})))}))}),[h,n,r,q]);f((()=>{!1===b&&E.current.isPositioned&&(E.current.isPositioned=!1,O((e=>({...e,isPositioned:!1}))))}),[b]);const I=i.useRef(!1);f((()=>(I.current=!0,()=>{I.current=!1})),[]),f((()=>{if(k&&(A.current=k),D&&(C.current=D),k&&D){if(U.current)return U.current(k,D,z);z()}}),[k,D,z,U,F]);const T=i.useMemo((()=>({reference:A,floating:C,setReference:x,setFloating:M})),[x,M]),$=i.useMemo((()=>({reference:k,floating:D})),[k,D]),L=i.useMemo((()=>{const e={position:r,left:0,top:0};if(!$.floating)return e;const t=a($.floating,w.x),n=a($.floating,w.y);return g?{...e,transform:"translate("+t+"px, "+n+"px)",...s($.floating)>=1.5&&{willChange:"transform"}}:{position:r,left:t,top:n}}),[r,g,$.floating,w.x,w.y]);return i.useMemo((()=>({...w,update:z,refs:T,elements:$,floatingStyles:L})),[w,z,T,$,L])}}));
+!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@floating-ui/dom"),require("react"),require("react-dom")):"function"==typeof define&&define.amd?define(["exports","@floating-ui/dom","react","react-dom"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FloatingUIReactDOM={},e.FloatingUIDOM,e.React,e.ReactDOM)}(this,(function(e,t,n,r){"use strict";function o(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var u=o(n),i=o(r);var f="undefined"!=typeof document?n.useLayoutEffect:n.useEffect;function c(e,t){if(e===t)return!0;if(typeof e!=typeof t)return!1;if("function"==typeof e&&e.toString()===t.toString())return!0;let n,r,o;if(e&&t&&"object"==typeof e){if(Array.isArray(e)){if(n=e.length,n!==t.length)return!1;for(r=n;0!=r--;)if(!c(e[r],t[r]))return!1;return!0}if(o=Object.keys(e),n=o.length,n!==Object.keys(t).length)return!1;for(r=n;0!=r--;)if(!{}.hasOwnProperty.call(t,o[r]))return!1;for(r=n;0!=r--;){const n=o[r];if(("_owner"!==n||!e.$$typeof)&&!c(e[n],t[n]))return!1}return!0}return e!=e&&t!=t}function a(e){if("undefined"==typeof window)return 1;return(e.ownerDocument.defaultView||window).devicePixelRatio||1}function l(e,t){const n=a(e);return Math.round(t*n)/n}function s(e){const t=u.useRef(e);return f((()=>{t.current=e})),t}Object.defineProperty(e,"autoPlacement",{enumerable:!0,get:function(){return t.autoPlacement}}),Object.defineProperty(e,"autoUpdate",{enumerable:!0,get:function(){return t.autoUpdate}}),Object.defineProperty(e,"computePosition",{enumerable:!0,get:function(){return t.computePosition}}),Object.defineProperty(e,"detectOverflow",{enumerable:!0,get:function(){return t.detectOverflow}}),Object.defineProperty(e,"flip",{enumerable:!0,get:function(){return t.flip}}),Object.defineProperty(e,"getOverflowAncestors",{enumerable:!0,get:function(){return t.getOverflowAncestors}}),Object.defineProperty(e,"hide",{enumerable:!0,get:function(){return t.hide}}),Object.defineProperty(e,"inline",{enumerable:!0,get:function(){return t.inline}}),Object.defineProperty(e,"limitShift",{enumerable:!0,get:function(){return t.limitShift}}),Object.defineProperty(e,"offset",{enumerable:!0,get:function(){return t.offset}}),Object.defineProperty(e,"platform",{enumerable:!0,get:function(){return t.platform}}),Object.defineProperty(e,"shift",{enumerable:!0,get:function(){return t.shift}}),Object.defineProperty(e,"size",{enumerable:!0,get:function(){return t.size}}),e.arrow=e=>({name:"arrow",options:e,fn(n){const{element:r,padding:o}="function"==typeof e?e(n):e;return r&&(u=r,{}.hasOwnProperty.call(u,"current"))?null!=r.current?t.arrow({element:r.current,padding:o}).fn(n):{}:r?t.arrow({element:r,padding:o}).fn(n):{};var u}}),e.useFloating=function(e){void 0===e&&(e={});const{placement:n="bottom",strategy:r="absolute",middleware:o=[],platform:d,elements:{reference:p,floating:m}={},transform:g=!0,whileElementsMounted:b,open:y}=e,[O,P]=u.useState({x:0,y:0,strategy:r,placement:n,middlewareData:{},isPositioned:!1}),[w,j]=u.useState(o);c(w,o)||j(o);const[h,v]=u.useState(null),[R,S]=u.useState(null),x=u.useCallback((e=>{e!==A.current&&(A.current=e,v(e))}),[]),M=u.useCallback((e=>{e!==C.current&&(C.current=e,S(e))}),[]),k=p||h,D=m||R,A=u.useRef(null),C=u.useRef(null),E=u.useRef(O),F=null!=b,U=s(b),q=s(d),z=u.useCallback((()=>{if(!A.current||!C.current)return;const e={placement:n,strategy:r,middleware:w};q.current&&(e.platform=q.current),t.computePosition(A.current,C.current,e).then((e=>{const t={...e,isPositioned:!0};I.current&&!c(E.current,t)&&(E.current=t,i.flushSync((()=>{P(t)})))}))}),[w,n,r,q]);f((()=>{!1===y&&E.current.isPositioned&&(E.current.isPositioned=!1,P((e=>({...e,isPositioned:!1}))))}),[y]);const I=u.useRef(!1);f((()=>(I.current=!0,()=>{I.current=!1})),[]),f((()=>{if(k&&(A.current=k),D&&(C.current=D),k&&D){if(U.current)return U.current(k,D,z);z()}}),[k,D,z,U,F]);const T=u.useMemo((()=>({reference:A,floating:C,setReference:x,setFloating:M})),[x,M]),$=u.useMemo((()=>({reference:k,floating:D})),[k,D]),L=u.useMemo((()=>{const e={position:r,left:0,top:0};if(!$.floating)return e;const t=l($.floating,O.x),n=l($.floating,O.y);return g?{...e,transform:"translate("+t+"px, "+n+"px)",...a($.floating)>=1.5&&{willChange:"transform"}}:{position:r,left:t,top:n}}),[r,g,$.floating,O.x,O.y]);return u.useMemo((()=>({...O,update:z,refs:T,elements:$,floatingStyles:L})),[O,z,T,$,L])}}));
